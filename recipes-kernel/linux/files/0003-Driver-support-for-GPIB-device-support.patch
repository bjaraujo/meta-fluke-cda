From f2a27fad83190204f874531d6ac5651d0cd425d8 Mon Sep 17 00:00:00 2001
From: Alex Dorchak <halfdome@fluke.com>
Date: Thu, 20 Oct 2016 14:55:11 -0700
Subject: [PATCH 3/3] Driver support for GPIB device support

---
 drivers/Kconfig                            |    2 +
 drivers/Makefile                           |    3 +
 drivers/gpib/Kconfig                       |   24 +
 drivers/gpib/Makefile                      |    3 +
 drivers/gpib/fluke_custom/Makefile         |    5 +
 drivers/gpib/fluke_custom/fluke_gpib.c     |  999 ++++++++++++++++++++
 drivers/gpib/fluke_custom/fluke_gpib.h     |  134 +++
 drivers/gpib/include/Makefile.am           |   16 +
 drivers/gpib/include/amcc5920.h            |   66 ++
 drivers/gpib/include/amccs5933.h           |   75 ++
 drivers/gpib/include/config.h              |   31 +
 drivers/gpib/include/gpibP.h               |   67 ++
 drivers/gpib/include/gpib_ioctl.h          |  179 ++++
 drivers/gpib/include/gpib_proto.h          |   55 ++
 drivers/gpib/include/gpib_state_machines.h |   36 +
 drivers/gpib/include/gpib_types.h          |  315 +++++++
 drivers/gpib/include/gpib_user.h           |  322 +++++++
 drivers/gpib/include/nec7210.h             |  148 +++
 drivers/gpib/include/nec7210_registers.h   |  243 +++++
 drivers/gpib/include/plx9050.h             |   85 ++
 drivers/gpib/include/quancom_pci.h         |   31 +
 drivers/gpib/include/tms9914.h             |  290 ++++++
 drivers/gpib/include/tnt4882_registers.h   |  211 +++++
 drivers/gpib/nec7210/Makefile              |    8 +
 drivers/gpib/nec7210/board.h               |   34 +
 drivers/gpib/nec7210/cmd.c                 |   87 ++
 drivers/gpib/nec7210/init.c                |  176 ++++
 drivers/gpib/nec7210/interrupt.c           |  196 ++++
 drivers/gpib/nec7210/nec7210_aux.c         |  174 ++++
 drivers/gpib/nec7210/read.c                |  183 ++++
 drivers/gpib/nec7210/util.c                |  273 ++++++
 drivers/gpib/nec7210/write.c               |  236 +++++
 drivers/gpib/sys/Makefile                  |    9 +
 drivers/gpib/sys/autopoll.c                |  159 ++++
 drivers/gpib/sys/autopoll.h                |   31 +
 drivers/gpib/sys/device.c                  |  202 ++++
 drivers/gpib/sys/event.c                   |  131 +++
 drivers/gpib/sys/ibcac.c                   |   50 +
 drivers/gpib/sys/ibcmd.c                   |   70 ++
 drivers/gpib/sys/ibgts.c                   |   45 +
 drivers/gpib/sys/ibinit.c                  |  139 +++
 drivers/gpib/sys/iblines.c                 |   25 +
 drivers/gpib/sys/ibread.c                  |   78 ++
 drivers/gpib/sys/ibrpp.c                   |   60 ++
 drivers/gpib/sys/ibrsv.c                   |   23 +
 drivers/gpib/sys/ibsic.c                   |   63 ++
 drivers/gpib/sys/ibsre.c                   |   39 +
 drivers/gpib/sys/ibsys.h                   |   21 +
 drivers/gpib/sys/ibutil.c                  |  134 +++
 drivers/gpib/sys/ibwait.c                  |  146 +++
 drivers/gpib/sys/ibwrite.c                 |   58 ++
 drivers/gpib/sys/osfuncs.c                 | 1408 ++++++++++++++++++++++++++++
 drivers/gpib/sys/osinit.c                  |  268 ++++++
 drivers/gpib/sys/ostimer.c                 |   64 ++
 drivers/gpib/sys/osutil.c                  |  101 ++
 55 files changed, 8031 insertions(+)
 create mode 100644 drivers/gpib/Kconfig
 create mode 100644 drivers/gpib/Makefile
 create mode 100644 drivers/gpib/fluke_custom/Makefile
 create mode 100644 drivers/gpib/fluke_custom/fluke_gpib.c
 create mode 100644 drivers/gpib/fluke_custom/fluke_gpib.h
 create mode 100644 drivers/gpib/include/Makefile.am
 create mode 100644 drivers/gpib/include/amcc5920.h
 create mode 100644 drivers/gpib/include/amccs5933.h
 create mode 100644 drivers/gpib/include/config.h
 create mode 100644 drivers/gpib/include/gpibP.h
 create mode 100644 drivers/gpib/include/gpib_ioctl.h
 create mode 100644 drivers/gpib/include/gpib_proto.h
 create mode 100644 drivers/gpib/include/gpib_state_machines.h
 create mode 100644 drivers/gpib/include/gpib_types.h
 create mode 100644 drivers/gpib/include/gpib_user.h
 create mode 100644 drivers/gpib/include/nec7210.h
 create mode 100644 drivers/gpib/include/nec7210_registers.h
 create mode 100644 drivers/gpib/include/plx9050.h
 create mode 100644 drivers/gpib/include/quancom_pci.h
 create mode 100644 drivers/gpib/include/tms9914.h
 create mode 100644 drivers/gpib/include/tnt4882_registers.h
 create mode 100644 drivers/gpib/nec7210/Makefile
 create mode 100644 drivers/gpib/nec7210/board.h
 create mode 100644 drivers/gpib/nec7210/cmd.c
 create mode 100644 drivers/gpib/nec7210/init.c
 create mode 100644 drivers/gpib/nec7210/interrupt.c
 create mode 100644 drivers/gpib/nec7210/nec7210_aux.c
 create mode 100644 drivers/gpib/nec7210/read.c
 create mode 100644 drivers/gpib/nec7210/util.c
 create mode 100644 drivers/gpib/nec7210/write.c
 create mode 100644 drivers/gpib/sys/Makefile
 create mode 100644 drivers/gpib/sys/autopoll.c
 create mode 100644 drivers/gpib/sys/autopoll.h
 create mode 100644 drivers/gpib/sys/device.c
 create mode 100644 drivers/gpib/sys/event.c
 create mode 100644 drivers/gpib/sys/ibcac.c
 create mode 100644 drivers/gpib/sys/ibcmd.c
 create mode 100644 drivers/gpib/sys/ibgts.c
 create mode 100644 drivers/gpib/sys/ibinit.c
 create mode 100644 drivers/gpib/sys/iblines.c
 create mode 100644 drivers/gpib/sys/ibread.c
 create mode 100644 drivers/gpib/sys/ibrpp.c
 create mode 100644 drivers/gpib/sys/ibrsv.c
 create mode 100644 drivers/gpib/sys/ibsic.c
 create mode 100644 drivers/gpib/sys/ibsre.c
 create mode 100644 drivers/gpib/sys/ibsys.h
 create mode 100644 drivers/gpib/sys/ibutil.c
 create mode 100644 drivers/gpib/sys/ibwait.c
 create mode 100644 drivers/gpib/sys/ibwrite.c
 create mode 100644 drivers/gpib/sys/osfuncs.c
 create mode 100644 drivers/gpib/sys/osinit.c
 create mode 100644 drivers/gpib/sys/ostimer.c
 create mode 100644 drivers/gpib/sys/osutil.c

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 9df7978..0c3d3c8 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -62,6 +62,8 @@ source "drivers/ptp/Kconfig"
 
 source "drivers/pinctrl/Kconfig"
 
+source "drivers/gpib/Kconfig"
+
 source "drivers/gpio/Kconfig"
 
 source "drivers/w1/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 3cf37ee..0a77e56 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -20,6 +20,9 @@ obj-$(CONFIG_RAPIDIO)		+= rapidio/
 obj-y				+= video/
 obj-y				+= idle/
 
+#gpib support
+obj-$(CONFIG_GPIB)     += gpib/
+
 # IPMI must come before ACPI in order to provide IPMI opregion support
 obj-$(CONFIG_IPMI_HANDLER)	+= char/ipmi/
 
diff --git a/drivers/gpib/Kconfig b/drivers/gpib/Kconfig
new file mode 100644
index 0000000..184b32c
--- /dev/null
+++ b/drivers/gpib/Kconfig
@@ -0,0 +1,24 @@
+
+#
+# NIOS2 gpib configuration
+#
+menuconfig GPIB
+    bool "GPIB Support"
+    help
+      This enables GPIB If unsure, say N.
+
+if GPIB
+config FLUKE_GPIB
+    tristate "FLUKE GPIB support"
+    help
+      This adds support for FLUKE's Custom GPIB.  The GPIB
+      is implemented on an Altera FPGA fabric utilizing a cb7210
+      vhdl design from Measurement Computing, which is connected
+      to an pl330 DMA controller.  The GPIB driver code is
+      based on the Linux GPIB project <http://linux-gpib.sf.net>, which was
+      modified by Frank Mori Hess to suit an Altera-FPGA design.
+
+      To compile gpib support as modules, choose M here: the modules
+      will be called gpib_common, nec7210, and fluke_gpib.
+endif
+
diff --git a/drivers/gpib/Makefile b/drivers/gpib/Makefile
new file mode 100644
index 0000000..e478c05
--- /dev/null
+++ b/drivers/gpib/Makefile
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_FLUKE_GPIB) += sys/ nec7210/ fluke_custom/
+
diff --git a/drivers/gpib/fluke_custom/Makefile b/drivers/gpib/fluke_custom/Makefile
new file mode 100644
index 0000000..f703aa0
--- /dev/null
+++ b/drivers/gpib/fluke_custom/Makefile
@@ -0,0 +1,5 @@
+EXTRA_CFLAGS += -Idrivers/gpib/include
+
+obj-$(CONFIG_FLUKE_GPIB) += fluke_gpib.o
+
+
diff --git a/drivers/gpib/fluke_custom/fluke_gpib.c b/drivers/gpib/fluke_custom/fluke_gpib.c
new file mode 100644
index 0000000..01286c1
--- /dev/null
+++ b/drivers/gpib/fluke_custom/fluke_gpib.c
@@ -0,0 +1,999 @@
+/***************************************************************************
+                          fluke_gpib.c  -  description
+                             -------------------
+GPIB Driver for Fluke cda devices.  Basically, its a driver for a (bugfixed) 
+cb7210 connected to channel 0 of a pl330 dma controller.
+
+    Author: Frank Mori Hess <fmh6jj@gmail.com>
+    copyright: (C) 2006, 2010, 2015 Fluke Corporation
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "fluke_gpib.h"
+
+#include "gpibP.h"
+#include <linux/dma-mapping.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+MODULE_LICENSE("GPL");
+
+int fluke_attach_holdoff_all(gpib_board_t *board, gpib_board_config_t config);
+int fluke_attach_holdoff_end(gpib_board_t *board, gpib_board_config_t config);
+void fluke_detach(gpib_board_t *board);
+static int fluke_config_dma(gpib_board_t *board, int output);
+irqreturn_t fluke_gpib_internal_interrupt(gpib_board_t *board);
+
+static struct platform_device *fluke_gpib_pdev = NULL;
+
+uint8_t fluke_locking_read_byte(nec7210_private_t *nec_priv, unsigned int register_number)
+{
+	uint8_t retval;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nec_priv->register_page_lock, flags);
+	retval = fluke_read_byte_nolock(nec_priv, register_number);
+	spin_unlock_irqrestore(&nec_priv->register_page_lock, flags);
+	return retval;
+}
+
+void fluke_locking_write_byte(nec7210_private_t *nec_priv, uint8_t byte, unsigned int register_number)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&nec_priv->register_page_lock, flags);
+	fluke_write_byte_nolock(nec_priv, byte, register_number);
+	spin_unlock_irqrestore(&nec_priv->register_page_lock, flags);
+}
+
+// wrappers for interface functions
+int fluke_read(gpib_board_t *board, uint8_t *buffer, size_t length, int *end, size_t *bytes_read)
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_read(board, &priv->nec7210_priv, buffer, length, end, bytes_read);
+}
+int fluke_write(gpib_board_t *board, uint8_t *buffer, size_t length, int send_eoi, size_t *bytes_written)
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_write(board, &priv->nec7210_priv, buffer, length, send_eoi, bytes_written);
+}
+ssize_t fluke_command(gpib_board_t *board, uint8_t *buffer, size_t length)
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_command(board, &priv->nec7210_priv, buffer, length);
+}
+int fluke_take_control(gpib_board_t *board, int synchronous)
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_take_control(board, &priv->nec7210_priv, synchronous);
+}
+int fluke_go_to_standby(gpib_board_t *board)
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_go_to_standby(board, &priv->nec7210_priv);
+}
+void fluke_request_system_control( gpib_board_t *board, int request_control )
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_private_t *nec_priv = &priv->nec7210_priv;
+	nec7210_request_system_control( board, nec_priv, request_control );
+}
+void fluke_interface_clear(gpib_board_t *board, int assert)
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_interface_clear(board, &priv->nec7210_priv, assert);
+}
+void fluke_remote_enable(gpib_board_t *board, int enable)
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_remote_enable(board, &priv->nec7210_priv, enable);
+}
+int fluke_enable_eos(gpib_board_t *board, uint8_t eos_byte, int compare_8_bits)
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_enable_eos(board, &priv->nec7210_priv, eos_byte, compare_8_bits);
+}
+void fluke_disable_eos(gpib_board_t *board)
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_disable_eos(board, &priv->nec7210_priv);
+}
+unsigned int fluke_update_status( gpib_board_t *board, unsigned int clear_mask )
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_update_status( board, &priv->nec7210_priv, clear_mask );
+}
+void fluke_primary_address(gpib_board_t *board, unsigned int address)
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_primary_address(board, &priv->nec7210_priv, address);
+}
+void fluke_secondary_address(gpib_board_t *board, unsigned int address, int enable)
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_secondary_address(board, &priv->nec7210_priv, address, enable);
+}
+int fluke_parallel_poll(gpib_board_t *board, uint8_t *result)
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_parallel_poll(board, &priv->nec7210_priv, result);
+}
+void fluke_parallel_poll_configure( gpib_board_t *board, uint8_t configuration )
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_parallel_poll_configure(board, &priv->nec7210_priv, configuration );
+}
+void fluke_parallel_poll_response( gpib_board_t *board, int ist )
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_parallel_poll_response(board, &priv->nec7210_priv, ist );
+}
+void fluke_serial_poll_response(gpib_board_t *board, uint8_t status)
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_serial_poll_response(board, &priv->nec7210_priv, status);
+}
+uint8_t fluke_serial_poll_status( gpib_board_t *board )
+{
+	fluke_private_t *priv = board->private_data;
+	return nec7210_serial_poll_status( board, &priv->nec7210_priv );
+}
+void fluke_return_to_local( gpib_board_t *board )
+{
+	fluke_private_t *priv = board->private_data;
+	nec7210_private_t *nec_priv = &priv->nec7210_priv;
+	write_byte(nec_priv, AUX_RTL2, AUXMR);
+	udelay(1);
+	write_byte(nec_priv, AUX_RTL, AUXMR);
+}
+int fluke_line_status( const gpib_board_t *board )
+{
+	int status = ValidALL;
+	int bsr_bits;
+	fluke_private_t *e_priv;
+	nec7210_private_t *nec_priv;
+
+	e_priv = board->private_data;
+	nec_priv = &e_priv->nec7210_priv;
+
+	bsr_bits = fluke_paged_read_byte(e_priv, BUS_STATUS, BUS_STATUS_PAGE);
+
+	if( ( bsr_bits & BSR_REN_BIT ) == 0 )
+		status |= BusREN;
+	if( ( bsr_bits & BSR_IFC_BIT ) == 0 )
+		status |= BusIFC;
+	if( ( bsr_bits & BSR_SRQ_BIT ) == 0 )
+		status |= BusSRQ;
+	if( ( bsr_bits & BSR_EOI_BIT ) == 0 )
+		status |= BusEOI;
+	if( ( bsr_bits & BSR_NRFD_BIT ) == 0 )
+		status |= BusNRFD;
+	if( ( bsr_bits & BSR_NDAC_BIT ) == 0 )
+		status |= BusNDAC;
+	if( ( bsr_bits & BSR_DAV_BIT ) == 0 )
+		status |= BusDAV;
+	if( ( bsr_bits & BSR_ATN_BIT ) == 0 )
+		status |= BusATN;
+
+	return status;
+}
+
+unsigned int fluke_t1_delay( gpib_board_t *board, unsigned int nano_sec )
+{
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	unsigned int retval;
+
+	retval = nec7210_t1_delay( board, nec_priv, nano_sec );
+
+	if( nano_sec <= 350 )
+	{
+		write_byte( nec_priv, AUX_HI_SPEED, AUXMR );
+		retval = 350;
+	}else
+		write_byte( nec_priv, AUX_LO_SPEED, AUXMR );
+
+	return retval;
+}
+
+static int wait_for_idle(gpib_board_t *board, short wake_on_listener_idle,
+	short wake_on_talker_idle)
+{
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	int retval = 0;
+// 	printk("%s: enter\n", __FUNCTION__);
+	if(wait_event_interruptible(board->wait,
+		(wake_on_listener_idle && test_bit(LACS_NUM, &board->status) == 0) ||
+		(wake_on_talker_idle && test_bit(TACS_NUM, &board->status) == 0) ||
+		test_bit(DEV_CLEAR_BN, &nec_priv->state) ||
+		test_bit(TIMO_NUM, &board->status)))
+	{
+		retval = -ERESTARTSYS;
+	}
+	if(test_bit(TIMO_NUM, &board->status))
+		retval = -ETIMEDOUT;
+	if(test_and_clear_bit(DEV_CLEAR_BN, &nec_priv->state))
+		retval = -EINTR;
+// 	printk("%s: exit, retval=%i\n", __FUNCTION__, retval);
+	return retval;
+}
+
+static void fluke_dma_callback(void *arg)
+{
+	gpib_board_t *board = arg;
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	unsigned long flags;
+	spin_lock_irqsave(&board->spinlock, flags);
+//	printk("%s: enter\n", __FUNCTION__);
+
+	nec7210_set_reg_bits(nec_priv, IMR1, HR_DOIE | HR_DIIE, HR_DOIE | HR_DIIE);
+	wake_up_interruptible(&board->wait);
+
+	fluke_gpib_internal_interrupt(board);
+	clear_bit(DMA_WRITE_IN_PROGRESS_BN, &nec_priv->state);
+	clear_bit(DMA_READ_IN_PROGRESS_BN, &nec_priv->state);
+//	printk("%s: exit\n", __FUNCTION__);
+	spin_unlock_irqrestore(&board->spinlock, flags);
+}
+
+static int fluke_dma_write(gpib_board_t *board, 
+	uint8_t *buffer, size_t length, size_t *bytes_written)
+{
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	unsigned long flags;
+	int retval = 0;
+	dma_addr_t address;
+	struct dma_async_tx_descriptor *tx_desc;
+	
+	*bytes_written = 0;
+// 	printk("%s: enter\n", __FUNCTION__);
+	if(length > e_priv->dma_buffer_size)
+		BUG();
+	dmaengine_terminate_all(e_priv->dma_channel);
+	// write-clear counter
+	writel(0x0, e_priv->write_transfer_counter);
+	retval = wait_for_idle(board, 1, 0);
+	if(retval < 0) return retval;
+	memcpy(e_priv->dma_buffer, buffer, length);
+	address = dma_map_single(NULL, e_priv->dma_buffer,
+		 length, DMA_TO_DEVICE);
+	/* program dma controller */
+	retval = fluke_config_dma(board, 1);
+	if(retval) goto cleanup;
+
+	tx_desc = dmaengine_prep_slave_single(e_priv->dma_channel, address, length, DMA_MEM_TO_DEV, 
+			DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if(tx_desc == NULL)
+	{
+		printk("fluke_gpib: failed to allocate dma transmit descriptor\n");
+		retval = -EIO;
+		goto cleanup;
+	}
+	tx_desc->callback = fluke_dma_callback;
+	tx_desc->callback_param = board;
+	
+	spin_lock_irqsave(&board->spinlock, flags);
+	nec7210_set_reg_bits(nec_priv, IMR1, HR_DOIE, 0);
+	nec7210_set_reg_bits(nec_priv, IMR2, HR_DMAO, HR_DMAO);
+	dmaengine_submit(tx_desc);
+	dma_async_issue_pending(e_priv->dma_channel);
+	clear_bit(WRITE_READY_BN, &nec_priv->state);
+	set_bit(DMA_WRITE_IN_PROGRESS_BN, &nec_priv->state);
+// 	printk("%s: in spin lock\n", __FUNCTION__);
+	spin_unlock_irqrestore(&board->spinlock, flags);
+
+//	printk("%s: waiting for write.\n", __FUNCTION__);
+	// suspend until message is sent
+	if(wait_event_interruptible(board->wait, 
+	   ((readl(e_priv->write_transfer_counter) & write_transfer_counter_mask) == length 
+			   /*&& test_bit(WRITE_READY_BN, &nec_priv->state) */) ||
+		test_bit(BUS_ERROR_BN, &nec_priv->state) || 
+		test_bit(DEV_CLEAR_BN, &nec_priv->state) ||
+		test_bit(TIMO_NUM, &board->status)))
+	{
+		GPIB_DPRINTK( "gpib write interrupted!\n" );
+		retval = -ERESTARTSYS;
+	}
+	if(test_bit(TIMO_NUM, &board->status))
+		retval = -ETIMEDOUT;
+	if(test_and_clear_bit(DEV_CLEAR_BN, &nec_priv->state))
+		retval = -EINTR;
+	if(test_and_clear_bit(BUS_ERROR_BN, &nec_priv->state))
+		retval = -EIO;
+	// disable board's dma
+	nec7210_set_reg_bits(nec_priv, IMR2, HR_DMAO, 0);
+
+	dmaengine_terminate_all(e_priv->dma_channel);
+	// make sure fluke_dma_callback got called
+	if(test_bit(DMA_WRITE_IN_PROGRESS_BN, &nec_priv->state))
+	{
+		fluke_dma_callback(board);
+	}
+
+	if(retval)
+		write_byte(nec_priv, AUX_NBAF, AUXMR);	
+	*bytes_written = readl(e_priv->write_transfer_counter) & write_transfer_counter_mask;
+	if(*bytes_written > length) BUG();
+	/*	printk("length=%i, *bytes_written=%i, residue=%i, retval=%i\n",
+		length, *bytes_written, get_dma_residue(e_priv->dma_channel), retval);*/
+cleanup:
+	dma_unmap_single(NULL, address, length, DMA_TO_DEVICE);
+//	printk("%s: exit, retval=%d\n", __FUNCTION__, retval);
+	return retval;
+}
+
+static int fluke_accel_write(gpib_board_t *board, 
+	uint8_t *buffer, size_t length, int send_eoi, size_t *bytes_written)
+{
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	size_t remainder = length;
+	size_t transfer_size;
+	ssize_t retval = 0;
+	size_t dma_remainder = remainder;
+	
+	if(e_priv->dma_channel == NULL) 
+	{
+		printk("fluke_gpib: No dma channel available, cannot do accel write.");
+		return -ENXIO;
+	}
+	
+	*bytes_written = 0;
+	if(length < 1) return 0;
+	clear_bit(DEV_CLEAR_BN, &nec_priv->state); // XXX FIXME
+	if(send_eoi) --dma_remainder;
+// 	printk("%s: entering while loop\n", __FUNCTION__);
+	
+	while(dma_remainder > 0)
+	{
+		size_t num_bytes;
+		transfer_size = (e_priv->dma_buffer_size < dma_remainder) ? 
+			e_priv->dma_buffer_size : dma_remainder;
+		retval = fluke_dma_write(board, buffer, transfer_size, &num_bytes);
+		*bytes_written += num_bytes;
+		if(retval < 0) break;
+		dma_remainder -= num_bytes;
+		remainder -= num_bytes;
+		buffer += num_bytes;
+		if(need_resched()) schedule();
+	}
+	if(retval < 0) return retval;
+	//handle sending of last byte with eoi
+	if(send_eoi)
+	{
+		size_t num_bytes;
+		// 		printk("%s: handling last byte\n", __FUNCTION__);
+		if(remainder != 1) BUG();
+		write_byte(nec_priv, AUX_SEOI, AUXMR);
+		retval = fluke_dma_write(board, buffer, remainder, &num_bytes);
+		*bytes_written += num_bytes;
+		if(retval < 0) return retval;
+		remainder -= num_bytes;
+	}
+// 	printk("%s: bytes send=%i\n", __FUNCTION__, (int)(length - remainder));
+	return 0;
+}
+
+static unsigned fluke_get_dma_residue(struct dma_chan *chan, dma_cookie_t cookie)
+{
+	struct dma_tx_state state;
+	int result;
+	
+	result = dmaengine_pause(chan);
+	if(result < 0)
+	{
+		printk("fluke_gpib: dma pause failed?\n");
+		BUG();
+	}
+	dmaengine_tx_status(chan, cookie, &state);
+	// hardware doesn't support resume, so dont call this
+	// method unless the dma transfer is done.
+	return state.residue;
+}
+
+static int fluke_dma_read(gpib_board_t *board, uint8_t *buffer,
+	size_t length, int *end, size_t *bytes_read)
+{
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	int retval = 0;
+	unsigned long flags;
+	unsigned residue;
+	int wait_retval;
+	dma_addr_t bus_address;
+	struct dma_async_tx_descriptor *tx_desc;
+	dma_cookie_t dma_cookie;
+	
+	// 	printk("%s: enter, bus_address=0x%x, length=%i\n", __FUNCTION__, (unsigned)bus_address,
+// 		   (int)length);
+
+	*bytes_read = 0;
+	*end = 0;
+	if(length == 0)
+		return 0;
+
+	retval = wait_for_idle(board, 0, 1);
+	if(retval < 0) return retval;
+	bus_address = dma_map_single(NULL, e_priv->dma_buffer,
+		length, DMA_FROM_DEVICE);
+
+	/* program dma controller */
+	retval = fluke_config_dma(board, 0);
+	if(retval) 
+	{
+		dma_unmap_single(NULL, bus_address, length, DMA_FROM_DEVICE);
+		return retval;
+	}
+	tx_desc = dmaengine_prep_slave_single(e_priv->dma_channel, bus_address, length, DMA_DEV_TO_MEM, 
+		DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if(tx_desc == NULL)
+	{
+		printk("fluke_gpib: failed to allocate dma transmit descriptor\n");
+		dma_unmap_single(NULL, bus_address, length, DMA_FROM_DEVICE);
+		return -EIO;
+	}
+	tx_desc->callback = fluke_dma_callback;
+	tx_desc->callback_param = board;
+
+	spin_lock_irqsave(&board->spinlock, flags);
+	// enable nec7210 dma
+	nec7210_set_reg_bits(nec_priv, IMR1, HR_DIIE, 0);
+	nec7210_set_reg_bits(nec_priv, IMR2, HR_DMAI, HR_DMAI);
+
+	dma_cookie = dmaengine_submit(tx_desc);
+	dma_async_issue_pending(e_priv->dma_channel);
+
+	set_bit(DMA_READ_IN_PROGRESS_BN, &nec_priv->state);
+	clear_bit(READ_READY_BN, &nec_priv->state);
+	
+	spin_unlock_irqrestore(&board->spinlock, flags);
+// 	printk("waiting for data transfer.\n");
+	// wait for data to transfer
+	if((wait_retval = wait_event_interruptible(board->wait,
+		test_bit(DMA_READ_IN_PROGRESS_BN, &nec_priv->state) == 0 ||
+		test_bit(RECEIVED_END_BN, &nec_priv->state) ||
+		test_bit(DEV_CLEAR_BN, &nec_priv->state) ||
+		test_bit(TIMO_NUM, &board->status))))
+	{
+		printk("fluke: dma read wait interrupted\n");
+		retval = -ERESTARTSYS;
+	}
+	if(test_bit(TIMO_NUM, &board->status))
+		retval = -ETIMEDOUT;
+	if(test_bit(DEV_CLEAR_BN, &nec_priv->state))
+		retval = -EINTR;
+	// stop the dma transfer
+	nec7210_set_reg_bits(nec_priv, IMR2, HR_DMAI, 0);
+	/* delay a little just to make sure any bytes in dma controller's fifo get
+	 written to memory before we disable it */
+	udelay(10);
+	residue = fluke_get_dma_residue(e_priv->dma_channel, dma_cookie);
+	BUG_ON(residue > length);
+	*bytes_read += length - residue;
+	dmaengine_terminate_all(e_priv->dma_channel);
+	// make sure fluke_dma_callback got called
+	if(test_bit(DMA_READ_IN_PROGRESS_BN, &nec_priv->state))
+	{
+		fluke_dma_callback(board);
+	}
+
+	dma_unmap_single(NULL, bus_address, length, DMA_FROM_DEVICE);
+	memcpy(buffer, e_priv->dma_buffer, *bytes_read);
+
+	/* If we got an end interrupt, figure out if it was
+	 * associated with the last byte we dma'd or with a
+	 * byte still sitting on the cb7210.
+	 */
+	spin_lock_irqsave(&board->spinlock, flags);
+	if(read_byte( nec_priv, ADR0 ) & DATA_IN_STATUS)
+	{
+		set_bit(READ_READY_BN, &nec_priv->state);
+	}else
+	{
+		clear_bit(READ_READY_BN, &nec_priv->state);
+		// There is no byte sitting on the cb7210.  If we
+		// saw an end interrupt, we need to deal with it now
+		if(test_and_clear_bit(RECEIVED_END_BN, &nec_priv->state)) 
+		{
+			*end = 1;
+		}
+	}
+	spin_unlock_irqrestore(&board->spinlock, flags);
+// 	printk("\tbytes_read=%i, residue=%i, end=%i, retval=%i, wait_retval=%i\n", 
+// 		   *bytes_read, residue, *end, retval, wait_retval);
+
+	return retval;
+}
+
+static ssize_t fluke_accel_read(gpib_board_t *board, uint8_t *buffer, size_t length,
+	int *end, size_t *bytes_read)
+{
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	size_t remain = length;
+	size_t transfer_size;
+	int retval = 0;
+	int dma_nbytes;
+/*	printk("%s: enter, buffer=0x%p, length=%i\n", __FUNCTION__,
+		   buffer, (int)length);
+	printk("\t dma_buffer=0x%p\n", e_priv->dma_buffer);*/
+	clear_bit(DEV_CLEAR_BN, &nec_priv->state); // XXX FIXME
+	*end = 0;
+	*bytes_read = 0;
+	nec7210_release_rfd_holdoff(board, nec_priv);
+// 	printk("%s: entering while loop\n", __FUNCTION__);
+	while(remain > 0)
+	{
+		transfer_size = (e_priv->dma_buffer_size < remain) ? e_priv->dma_buffer_size : remain;
+		retval = fluke_dma_read(board, buffer, transfer_size, end, &dma_nbytes);
+		remain -= dma_nbytes;
+		buffer += dma_nbytes;
+		*bytes_read += dma_nbytes;
+		if(*end) 
+		{
+			break;
+		}
+		if(retval < 0) 
+		{
+// 			printk("%s: early exit, retval=%i\n", __FUNCTION__, (int)retval);
+			return retval;
+		}
+		if(need_resched()) schedule();
+	}
+// 	printk("%s: exit, retval=%i\n", __FUNCTION__, (int)retval);
+	return retval;
+}
+
+gpib_interface_t fluke_unaccel_interface =
+{
+	name: "fluke_unaccel",
+	attach: fluke_attach_holdoff_all,
+	detach: fluke_detach,
+	read: fluke_read,
+	write: fluke_write,
+	command: fluke_command,
+	take_control: fluke_take_control,
+	go_to_standby: fluke_go_to_standby,
+	request_system_control: fluke_request_system_control,
+	interface_clear: fluke_interface_clear,
+	remote_enable: fluke_remote_enable,
+	enable_eos: fluke_enable_eos,
+	disable_eos: fluke_disable_eos,
+	parallel_poll: fluke_parallel_poll,
+	parallel_poll_configure: fluke_parallel_poll_configure,
+	parallel_poll_response: fluke_parallel_poll_response,
+	line_status: fluke_line_status,
+	update_status: fluke_update_status,
+	primary_address: fluke_primary_address,
+	secondary_address: fluke_secondary_address,
+	serial_poll_response: fluke_serial_poll_response,
+	serial_poll_status: fluke_serial_poll_status,
+	t1_delay: fluke_t1_delay,
+	return_to_local: fluke_return_to_local,
+};
+
+/* fluke_hybrid uses dma for writes but not for reads.  Added
+ to deal with occasional corruption of bytes seen when doing dma
+ reads.  From looking at the cb7210 vhdl, I believe the corruption
+ is due to a hardware bug triggered by the cpu reading a cb7210
+ register just as the dma controller is also doing a read. */
+gpib_interface_t fluke_hybrid_interface =
+{
+	name: "fluke_hybrid",
+	attach: fluke_attach_holdoff_all,
+	detach: fluke_detach,
+	read: fluke_read,
+	write: fluke_accel_write,
+	command: fluke_command,
+	take_control: fluke_take_control,
+	go_to_standby: fluke_go_to_standby,
+	request_system_control: fluke_request_system_control,
+	interface_clear: fluke_interface_clear,
+	remote_enable: fluke_remote_enable,
+	enable_eos: fluke_enable_eos,
+	disable_eos: fluke_disable_eos,
+	parallel_poll: fluke_parallel_poll,
+	parallel_poll_configure: fluke_parallel_poll_configure,
+	parallel_poll_response: fluke_parallel_poll_response,
+	line_status: fluke_line_status,
+	update_status: fluke_update_status,
+	primary_address: fluke_primary_address,
+	secondary_address: fluke_secondary_address,
+	serial_poll_response: fluke_serial_poll_response,
+	serial_poll_status: fluke_serial_poll_status,
+	t1_delay: fluke_t1_delay,
+	return_to_local: fluke_return_to_local,
+};
+
+gpib_interface_t fluke_interface =
+{
+	name: "fluke",
+	attach: fluke_attach_holdoff_end,
+	detach: fluke_detach,
+	read: fluke_accel_read,
+	write: fluke_accel_write,
+	command: fluke_command,
+	take_control: fluke_take_control,
+	go_to_standby: fluke_go_to_standby,
+	request_system_control: fluke_request_system_control,
+	interface_clear: fluke_interface_clear,
+	remote_enable: fluke_remote_enable,
+	enable_eos: fluke_enable_eos,
+	disable_eos: fluke_disable_eos,
+	parallel_poll: fluke_parallel_poll,
+	parallel_poll_configure: fluke_parallel_poll_configure,
+	parallel_poll_response: fluke_parallel_poll_response,
+	line_status: fluke_line_status,
+	update_status: fluke_update_status,
+	primary_address: fluke_primary_address,
+	secondary_address: fluke_secondary_address,
+	serial_poll_response: fluke_serial_poll_response,
+	serial_poll_status: fluke_serial_poll_status,
+	t1_delay: fluke_t1_delay,
+	return_to_local: fluke_return_to_local,
+};
+
+irqreturn_t fluke_gpib_internal_interrupt(gpib_board_t *board)
+{
+	int status1, status2;
+	fluke_private_t *priv = board->private_data;
+	nec7210_private_t *nec_priv = &priv->nec7210_priv;
+	int retval;
+	status1 = read_byte( nec_priv, ISR1 );
+	status2 = read_byte( nec_priv, ISR2 );
+	retval = nec7210_interrupt_have_status(board, nec_priv, status1, status2);
+
+/* 
+	if((status1 & nec_priv->reg_bits[IMR1]) ||
+		(status2 & (nec_priv->reg_bits[IMR2] & IMR2_ENABLE_INTR_MASK)))
+	{
+		printk("fluke: status1 0x%x, status2 0x%x\n", status1, status2);
+	}
+*/
+
+	return retval;
+}
+
+irqreturn_t fluke_gpib_interrupt(int irq, void *arg)
+{
+	gpib_board_t *board = arg;
+	unsigned long flags;
+	irqreturn_t retval;
+	
+	spin_lock_irqsave(&board->spinlock, flags);
+	retval = fluke_gpib_internal_interrupt(board);
+	spin_unlock_irqrestore(&board->spinlock, flags);
+	return retval;
+}
+
+int fluke_allocate_private(gpib_board_t *board)
+{
+	fluke_private_t *priv;
+
+	board->private_data = kmalloc(sizeof(fluke_private_t), GFP_KERNEL);
+	if(board->private_data == NULL)
+		return -ENOMEM;
+	priv = board->private_data;
+	memset( priv, 0, sizeof(fluke_private_t));
+	init_nec7210_private(&priv->nec7210_priv);
+	priv->dma_buffer_size = 0x7ff;
+	priv->dma_buffer = kmalloc(priv->dma_buffer_size, GFP_KERNEL);
+	if(priv->dma_buffer == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+void fluke_generic_detach(gpib_board_t *board)
+{
+	if(board->private_data)
+	{
+		fluke_private_t *e_priv = board->private_data;
+		if(e_priv->dma_buffer)
+			kfree(e_priv->dma_buffer);
+		kfree(board->private_data);
+		board->private_data = NULL;
+	}
+}
+
+// generic part of attach functions shared by all cb7210 boards
+int fluke_generic_attach(gpib_board_t *board)
+{
+	fluke_private_t *e_priv;
+	nec7210_private_t *nec_priv;
+	int retval;
+
+	board->status = 0;
+
+	retval = fluke_allocate_private(board);
+	if(retval < 0)
+		return retval;
+	e_priv = board->private_data;
+	nec_priv = &e_priv->nec7210_priv;
+	nec_priv->read_byte = fluke_locking_read_byte;
+	nec_priv->write_byte = fluke_locking_write_byte;
+	nec_priv->offset = fluke_reg_offset;
+	nec_priv->type = CB7210;
+	return 0;
+}
+
+static int fluke_config_dma(gpib_board_t *board, int output)
+{
+	fluke_private_t *e_priv = board->private_data;
+	struct dma_slave_config config;
+	config.src_maxburst = 1;
+	config.dst_maxburst = 1;
+	config.device_fc = true;
+	config.slave_id = 0;
+	
+	if(output)
+	{
+		config.direction = DMA_MEM_TO_DEV;
+		config.src_addr = 0;
+		config.dst_addr = e_priv->dma_port_res->start;
+		config.src_addr_width = 1;
+		config.dst_addr_width = 1;
+	}else
+	{
+		config.direction = DMA_DEV_TO_MEM;
+		config.src_addr = e_priv->dma_port_res->start;
+		config.dst_addr = 0;
+		config.src_addr_width = 1;
+		config.dst_addr_width = 1;
+	}
+	return dmaengine_slave_config(e_priv->dma_channel, &config);
+}
+
+int fluke_init(fluke_private_t *e_priv, gpib_board_t *board, int handshake_mode)
+{
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+
+	nec7210_board_reset(nec_priv, board);
+	write_byte(nec_priv, AUX_LO_SPEED, AUXMR);
+	/* set clock register for driving frequency
+	 * ICR should be set to clock in megahertz (1-15) and to zero
+	 * for clocks faster than 15 MHz (max 20MHz) */
+	write_byte(nec_priv, ICR | 10, AUXMR);
+	nec7210_set_handshake_mode(board, nec_priv, handshake_mode);
+
+	nec7210_board_online( nec_priv, board );
+
+	/* poll so we can detect ATN changes */
+	if(gpib_request_pseudo_irq(board, fluke_gpib_interrupt))
+	{
+		printk("fluke_gpib: failed to allocate pseudo_irq\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This function is passed to dma_request_channel() in order to
+ * select the pl330 dma channel which has been hardwired to
+ * the gpib controller. */
+static bool gpib_dma_channel_filter(struct dma_chan *chan, void *filter_param)
+{
+	// select the channel which is wired to the gpib chip
+	return chan->chan_id == 0;
+}
+
+static int fluke_attach_impl(gpib_board_t *board, gpib_board_config_t config, unsigned handshake_mode)
+{
+	fluke_private_t *e_priv;
+	nec7210_private_t *nec_priv;
+	int isr_flags = 0;
+	int retval;
+	int irq;
+	struct resource *res;
+	dma_cap_mask_t dma_cap;
+	
+	if(!fluke_gpib_pdev)
+	{
+		printk("No gpib platform device was found, attach failed.");
+		return -ENODEV;
+	}
+	
+	retval = fluke_generic_attach(board);
+	if(retval) return retval;
+
+	e_priv = board->private_data;
+	nec_priv = &e_priv->nec7210_priv;
+	nec_priv->offset = fluke_reg_offset;	
+	
+	res = platform_get_resource(fluke_gpib_pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&fluke_gpib_pdev->dev, "Unable to locate mmio resource for cb7210 gpib\n");
+		return -ENODEV;
+	}
+
+	if(request_mem_region(res->start,
+			resource_size(res),
+			fluke_gpib_pdev->name) == NULL) {
+		dev_err(&fluke_gpib_pdev->dev, "cannot claim registers\n");
+		return -ENXIO;
+        }
+        e_priv->gpib_iomem_res = res;
+
+	nec_priv->iobase = ioremap_nocache(e_priv->gpib_iomem_res->start, 
+			resource_size(e_priv->gpib_iomem_res));
+	printk("gpib: iobase %lx remapped to %p, length=%d\n", (unsigned long)e_priv->gpib_iomem_res->start,
+		nec_priv->iobase, resource_size(e_priv->gpib_iomem_res));
+	if (!nec_priv->iobase) {
+		dev_err(&fluke_gpib_pdev->dev, "Could not map I/O memory\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(fluke_gpib_pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&fluke_gpib_pdev->dev, "Unable to locate mmio resource for gpib dma port\n");
+		return -ENODEV;
+	}
+	if(request_mem_region(res->start,
+			resource_size(res),
+			fluke_gpib_pdev->name) == NULL) {
+		dev_err(&fluke_gpib_pdev->dev, "cannot claim registers\n");
+		return -ENXIO;
+        }
+        e_priv->dma_port_res = res;
+
+	res = platform_get_resource(fluke_gpib_pdev, IORESOURCE_MEM, 2);
+	if (!res) {
+		dev_err(&fluke_gpib_pdev->dev, "Unable to locate mmio resource for write transfer counter\n");
+		return -ENODEV;
+	}
+
+	if(request_mem_region(res->start,
+			resource_size(res),
+			fluke_gpib_pdev->name) == NULL) {
+		dev_err(&fluke_gpib_pdev->dev, "cannot claim registers\n");
+		return -ENXIO;
+        }
+        e_priv->write_transfer_counter_res = res;
+
+	e_priv->write_transfer_counter = ioremap_nocache(e_priv->write_transfer_counter_res->start, 
+			resource_size(e_priv->write_transfer_counter_res));
+	printk("gpib: write transfer counter %lx remapped to %p, length=%d\n",
+		(unsigned long)e_priv->write_transfer_counter_res->start, e_priv->write_transfer_counter, 
+		resource_size(e_priv->write_transfer_counter_res));
+	if (!e_priv->write_transfer_counter) {
+		dev_err(&fluke_gpib_pdev->dev, "Could not map I/O memory\n");
+		return -ENOMEM;
+	}
+
+	irq = platform_get_irq(fluke_gpib_pdev, 0);
+	printk("gpib: irq %d\n", irq);
+	if(irq < 0)
+	{
+		dev_err(&fluke_gpib_pdev->dev, "fluke_gpib: request for IRQ failed\n");
+		return -EBUSY;
+	}
+	retval = request_irq(irq, fluke_gpib_interrupt, isr_flags, fluke_gpib_pdev->name, board);
+	if(retval){
+		dev_err(&fluke_gpib_pdev->dev,
+			"cannot register interrupt handler err=%d\n",
+				retval);
+		return retval;
+	}
+	e_priv->irq = irq;
+
+        dma_cap_zero(dma_cap);
+        dma_cap_set(DMA_SLAVE, dma_cap);
+	e_priv->dma_channel = dma_request_channel(dma_cap, gpib_dma_channel_filter, NULL);
+	if(e_priv->dma_channel == NULL) 
+	{
+		printk( "fluke_gpib: failed to allocate a dma channel.\n");
+		// we don't error out here because unaccel interface will still
+		// work without dma
+	}
+	
+	return fluke_init(e_priv, board, handshake_mode);
+}
+
+int fluke_attach_holdoff_all(gpib_board_t *board, gpib_board_config_t config)
+{
+	return fluke_attach_impl(board, config, HR_HLDA);
+}
+
+int fluke_attach_holdoff_end(gpib_board_t *board, gpib_board_config_t config)
+{
+	return fluke_attach_impl(board, config, HR_HLDE);
+}
+
+void fluke_detach(gpib_board_t *board)
+{
+	fluke_private_t *e_priv = board->private_data;
+	nec7210_private_t *nec_priv;
+
+	if(e_priv)
+	{
+		if(e_priv->dma_channel != NULL)
+			dma_release_channel(e_priv->dma_channel);
+		gpib_free_pseudo_irq(board);
+		nec_priv = &e_priv->nec7210_priv;
+
+		if(nec_priv->iobase)
+		{
+			nec7210_board_reset(nec_priv, board);
+		}
+		if(e_priv->irq)
+		{
+			free_irq(e_priv->irq, board);
+		}
+		if(e_priv->write_transfer_counter_res)
+		{
+			release_mem_region(e_priv->write_transfer_counter_res->start, 
+				resource_size(e_priv->write_transfer_counter_res));
+		}
+		if(e_priv->dma_port_res)
+		{
+			release_mem_region(e_priv->dma_port_res->start, 
+				resource_size(e_priv->dma_port_res));
+		}
+		if(e_priv->gpib_iomem_res)
+		{
+			release_mem_region(e_priv->gpib_iomem_res->start, 
+				resource_size(e_priv->gpib_iomem_res));
+		}
+	}
+	fluke_generic_detach(board);
+}
+
+static int fluke_gpib_probe(struct platform_device *pdev) {
+	fluke_gpib_pdev = pdev;
+	return 0;
+}
+
+static const struct of_device_id fluke_gpib_of_match[] = {
+	{ .compatible = "flk,fgpib-4.0"},
+	{ {0} }
+};
+MODULE_DEVICE_TABLE(of, fluke_gpib_of_match);
+
+static struct platform_driver fluke_gpib_platform_driver = {
+	.driver = {
+		.name = "fluke_gpib",
+		.owner = THIS_MODULE,
+		.of_match_table = fluke_gpib_of_match,
+	},
+	.probe = &fluke_gpib_probe
+};
+
+static int __init fluke_init_module( void )
+{
+	int result;
+	
+	result = platform_driver_register(&fluke_gpib_platform_driver);
+	if (result) {
+		printk("fluke_gpib: platform_driver_register failed!\n");
+		return result;
+	}
+	
+	gpib_register_driver(&fluke_unaccel_interface, THIS_MODULE);
+	gpib_register_driver(&fluke_hybrid_interface, THIS_MODULE);
+	gpib_register_driver(&fluke_interface, THIS_MODULE);
+
+	printk("fluke_gpib\n");
+	return 0;
+}
+
+static void __exit fluke_exit_module( void )
+{
+	gpib_unregister_driver(&fluke_unaccel_interface);
+	gpib_unregister_driver(&fluke_hybrid_interface);
+	gpib_unregister_driver(&fluke_interface);
+	platform_driver_unregister(&fluke_gpib_platform_driver);
+}
+
+module_init( fluke_init_module );
+module_exit( fluke_exit_module );
diff --git a/drivers/gpib/fluke_custom/fluke_gpib.h b/drivers/gpib/fluke_custom/fluke_gpib.h
new file mode 100644
index 0000000..72d0582
--- /dev/null
+++ b/drivers/gpib/fluke_custom/fluke_gpib.h
@@ -0,0 +1,134 @@
+/***************************************************************************
+                              fluke_gpib.h
+                             -------------------
+
+    Author: Frank Mori Hess <fmh6jj@gmail.com>
+    copyright: (C) 2006, 2010, 2015 Fluke Corporation
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _FLUKE_GPIB_H
+#define _FLUKE_GPIB_H
+
+#include <linux/compiler.h>
+#include <linux/dmaengine.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include "nec7210.h"
+#include <linux/interrupt.h>
+
+typedef struct
+{
+	nec7210_private_t nec7210_priv;
+	struct resource *gpib_iomem_res;
+	struct resource *write_transfer_counter_res;
+	struct resource *dma_port_res;
+	int irq;
+	struct dma_chan *dma_channel;
+	uint8_t *dma_buffer;
+	int dma_buffer_size;
+	void *write_transfer_counter;
+} fluke_private_t;
+
+
+// cb7210 specific registers and bits
+enum cb7210_regs
+{
+	BUS_STATUS = 0x7,
+};
+enum cb7210_page_in
+{
+	BUS_STATUS_PAGE = 1,
+};
+// we customized the cb7210 vhdl to give the "data in" status
+// on the unused bit 7 of the address0 register.
+enum cb7210_address0
+{
+	DATA_IN_STATUS = 0x80
+};
+
+static inline int cb7210_page_in_bits(unsigned int page)
+{
+	return 0x50 | (page & 0xf);
+}
+// don't use without locking nec_priv->register_page_lock
+static inline uint8_t fluke_read_byte_nolock(nec7210_private_t *nec_priv,
+	int register_num)
+{
+	uint8_t retval;
+
+	retval = readl(nec_priv->iobase + register_num * nec_priv->offset);
+	return retval;
+}
+// don't use without locking nec_priv->register_page_lock
+static inline void fluke_write_byte_nolock(nec7210_private_t *nec_priv,
+	uint8_t data, int register_num)
+{
+	writel(data, nec_priv->iobase + register_num * nec_priv->offset);
+}
+static inline uint8_t fluke_paged_read_byte(fluke_private_t *e_priv,
+	unsigned int register_num, unsigned int page)
+{
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	uint8_t retval;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nec_priv->register_page_lock, flags);
+	fluke_write_byte_nolock(nec_priv, cb7210_page_in_bits(page), AUXMR);
+	udelay(1);
+	retval = fluke_read_byte_nolock(nec_priv, register_num);
+	spin_unlock_irqrestore(&nec_priv->register_page_lock, flags);
+	return retval;
+}
+static inline void fluke_paged_write_byte(fluke_private_t *e_priv,
+	uint8_t data, unsigned int register_num, unsigned int page)
+{
+	nec7210_private_t *nec_priv = &e_priv->nec7210_priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nec_priv->register_page_lock, flags);
+	fluke_write_byte_nolock(nec_priv, cb7210_page_in_bits(page), AUXMR);
+	udelay(1);
+	fluke_write_byte_nolock(nec_priv, data, register_num);
+	spin_unlock_irqrestore(&nec_priv->register_page_lock, flags);
+}
+
+enum bus_status_bits
+{
+	BSR_ATN_BIT = 0x1,
+	BSR_EOI_BIT = 0x2,
+	BSR_SRQ_BIT = 0x4,
+	BSR_IFC_BIT = 0x8,
+	BSR_REN_BIT = 0x10,
+	BSR_DAV_BIT = 0x20,
+	BSR_NRFD_BIT = 0x40,
+	BSR_NDAC_BIT = 0x80,
+};
+
+
+enum cb7210_aux_cmds
+{
+/* AUX_RTL2 is an undocumented aux command which causes cb7210 to assert 
+	(and keep asserted) local rtl message.  This is used in conjunction 
+	with the (stupid) cb7210 implementation
+	of the normal nec7210 AUX_RTL aux command, which
+	causes the rtl message to toggle between on and off. */
+	AUX_RTL2 = 0xd,
+	AUX_NBAF = 0xe,	// new byte available false (also clears seoi)
+	AUX_LO_SPEED = 0x40,
+	AUX_HI_SPEED = 0x41,
+};
+
+static const int fluke_reg_offset = 4;
+static const int fluke_num_regs = 8;
+static const unsigned write_transfer_counter_mask = 0x7ff;
+
+#endif	// _FLUKE_GPIB_H
diff --git a/drivers/gpib/include/Makefile.am b/drivers/gpib/include/Makefile.am
new file mode 100644
index 0000000..d666704
--- /dev/null
+++ b/drivers/gpib/include/Makefile.am
@@ -0,0 +1,16 @@
+# driver/include/Makefile.am
+# copyright (C) 2003 by Frank Mori Hess
+# email : fmhess@users.sourceforge.net
+#
+#   This Makefile.am is free software; you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation; either version 2 of the License, or
+#   (at your option) any later version.
+
+EXTRA_DIST = amcc5920.h amccs5933.h gpibP.h gpib_ioctl.h gpib_proto.h \
+	gpib_types.h gpib_user.h nec7210.h nec7210_registers.h plx9050.h \
+	quancom_pci.h tms9914.h tnt4882_registers.h \
+	linux/*.h
+
+headersdir = $(includedir)/gpib
+headers_HEADERS = gpib_user.h
diff --git a/drivers/gpib/include/amcc5920.h b/drivers/gpib/include/amcc5920.h
new file mode 100644
index 0000000..bcfdd32
--- /dev/null
+++ b/drivers/gpib/include/amcc5920.h
@@ -0,0 +1,66 @@
+/***************************************************************************
+                          amcc5920.h  -  description
+                             -------------------
+  Header for amcc5920 pci chip
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _AMCC5920_GPIB_H
+#define _AMCC5920_GPIB_H
+
+// plx pci chip registers and bits
+enum amcc_registers
+{
+	AMCC_INTCS_REG = 0x38,
+	AMCC_PASS_THRU_REG	= 0x60,
+};
+
+enum amcc_incsr_bits
+{
+	AMCC_ADDON_INTR_ENABLE_BIT = 0x2000,
+	AMCC_ADDON_INTR_ACTIVE_BIT = 0x400000,
+	AMCC_INTR_ACTIVE_BIT = 0x800000,
+};
+
+static const int bits_per_region = 8;
+
+static inline uint32_t amcc_wait_state_bits(unsigned int region, unsigned int num_wait_states)
+{
+	return (num_wait_states & 0x7) << ( --region * bits_per_region );
+};
+
+enum amcc_prefetch_bits
+{
+	PREFETCH_DISABLED = 0x0,
+	PREFETCH_SMALL = 0x8,
+	PREFETCH_MEDIUM = 0x10,
+	PREFETCH_LARGE = 0x18,
+};
+
+static inline uint32_t amcc_prefetch_bits(unsigned int region, enum amcc_prefetch_bits prefetch)
+{
+	return prefetch << ( --region * bits_per_region );
+};
+
+static inline uint32_t amcc_PTADR_mode_bit(unsigned int region)
+{
+	return 0x80 << ( --region * bits_per_region);
+};
+
+static inline uint32_t amcc_disable_write_fifo_bit(unsigned int region)
+{
+	return 0x20 << ( --region * bits_per_region);
+};
+
+#endif	// _AMCC5920_GPIB_H
diff --git a/drivers/gpib/include/amccs5933.h b/drivers/gpib/include/amccs5933.h
new file mode 100644
index 0000000..e4fbbf0
--- /dev/null
+++ b/drivers/gpib/include/amccs5933.h
@@ -0,0 +1,75 @@
+/***************************************************************************
+                              nec7210/amccs5933.h
+                             -------------------
+
+Registers and bits for amccs5933 pci chip
+
+    begin                : Jan 2002
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef _AMCCS5933_H
+#define _AMCCS5933_H
+
+// register offsets
+enum
+{
+	MBEF_REG = 0x34,	// mailbux empty/full
+	INTCSR_REG = 0x38,	// interrupt control and status
+	BMCSR_REG = 0x3c,	// bus master control and status
+};
+// incoming mailbox 0-3  register offsets
+extern inline int INCOMING_MAILBOX_REG(unsigned int mailbox)
+{
+	return (0x10 + 4 * mailbox);
+};
+
+// bit definitions
+
+// INTCSR bits
+enum
+{
+	OUTBOX_EMPTY_INTR_BIT = 0x10,	// enable outbox empty interrupt
+	INBOX_FULL_INTR_BIT = 0x1000,	// enable inbox full interrupt
+	INBOX_INTR_CS_BIT = 0x20000, // read, or write clear inbox full interrupt
+	INTR_ASSERTED_BIT = 0x800000,	// read only, interrupt asserted
+};
+// select byte 0 to 3 of incoming mailbox
+extern inline int INBOX_BYTE_BITS(unsigned int byte)
+{
+	return (byte & 0x3) << 8;
+};
+// select incoming mailbox 0 to 3
+extern inline int INBOX_SELECT_BITS(unsigned int mailbox)
+{
+	return (mailbox & 0x3) << 10;
+};
+// select byte 0 to 3 of outgoing mailbox
+extern inline int OUTBOX_BYTE_BITS(unsigned int byte)
+{
+	return (byte & 0x3);
+};
+// select outgoing mailbox 0 to 3
+extern inline int OUTBOX_SELECT_BITS(unsigned int mailbox)
+{
+	return (mailbox & 0x3) << 2;
+};
+
+//BMCSR bits
+enum
+{
+	MBOX_FLAGS_RESET_BIT = 0x08000000,	// resets mailbox empty/full flags
+};
+
+#endif	// _AMCCS5933_H
diff --git a/drivers/gpib/include/config.h b/drivers/gpib/include/config.h
new file mode 100644
index 0000000..6cc2c79
--- /dev/null
+++ b/drivers/gpib/include/config.h
@@ -0,0 +1,31 @@
+/* Define to enable debug spam to console in drivers */
+/* #undef GPIB_CONFIG_KERNEL_DEBUG */
+/* #define GPIB_CONFIG_KERNEL_DEBUG 1 */
+
+/* Define to enable pcmcia support in drivers */
+/* #undef GPIB_CONFIG_PCMCIA */
+
+/* Major number of device files */
+#define IBMAJOR 160
+
+/* Name of package */
+#define PACKAGE "linux-gpib"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "linux-gpib"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "linux-gpib 3.2.21-fluke"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "linux-gpib"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "3.2.21-fluke"
+
+/* Version number of package */
+#define VERSION "3.2.21-fluke"
+
diff --git a/drivers/gpib/include/gpibP.h b/drivers/gpib/include/gpibP.h
new file mode 100644
index 0000000..4b5b186
--- /dev/null
+++ b/drivers/gpib/include/gpibP.h
@@ -0,0 +1,67 @@
+/***************************************************************************
+                          gpibP.h
+                             -------------------
+
+    copyright            : (C) 2002,2003 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _GPIB_P_H
+#define _GPIB_P_H
+
+#include <linux/types.h>
+
+#include "gpib_user.h"
+#include "gpib_types.h"
+#include "gpib_proto.h"
+#include "gpib_ioctl.h"
+#include "config.h"
+
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+
+void gpib_register_driver(gpib_interface_t *interface, struct module *mod);
+void gpib_unregister_driver(gpib_interface_t *interface);
+struct pci_dev* gpib_pci_get_device( const gpib_board_t *board, unsigned int vendor_id,
+	unsigned int device_id, struct pci_dev *from);
+struct pci_dev* gpib_pci_get_subsys( const gpib_board_t *board, unsigned int vendor_id,
+	unsigned int device_id, unsigned ss_vendor, unsigned ss_device,
+	struct pci_dev *from);
+unsigned int num_gpib_events( const gpib_event_queue_t *queue );
+int push_gpib_event( gpib_board_t *board, short event_type );
+int pop_gpib_event( gpib_event_queue_t *queue, short *event_type );
+int gpib_request_pseudo_irq(gpib_board_t *board, irqreturn_t (*handler)(int, void * PT_REGS_ARG));
+void gpib_free_pseudo_irq(gpib_board_t *board);
+
+extern gpib_board_t board_array[GPIB_MAX_NUM_BOARDS];
+
+extern struct list_head registered_drivers;
+
+#if defined( GPIB_CONFIG_KERNEL_DEBUG )
+#define GPIB_DPRINTK( format, args... ) printk( "gpib debug: " format, ## args )
+#else
+#define GPIB_DPRINTK( arg... )
+#endif
+
+#include <asm/io.h>
+
+void writeb_wrapper(unsigned int value, void *address);
+unsigned int readb_wrapper(void *address);
+void outb_wrapper(unsigned int value, void *address);
+unsigned int inb_wrapper(void *address);
+void writew_wrapper(unsigned int value, void *address);
+unsigned int readw_wrapper(void *address);
+void outw_wrapper(unsigned int value, void *address);
+unsigned int inw_wrapper(void *address);
+
+#endif	// _GPIB_P_H
+
diff --git a/drivers/gpib/include/gpib_ioctl.h b/drivers/gpib/include/gpib_ioctl.h
new file mode 100644
index 0000000..9215fcc
--- /dev/null
+++ b/drivers/gpib/include/gpib_ioctl.h
@@ -0,0 +1,179 @@
+/***************************************************************************
+                          gpib_ioctl.h  -  header file for gpib library
+                             -------------------
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef _GPIB_IOCTL_H
+#define _GPIB_IOCTL_H
+
+#include <asm/ioctl.h>
+#include <linux/types.h>
+
+#define GPIB_CODE 160
+
+typedef struct
+{
+	char name[100];
+} board_type_ioctl_t;
+
+/* argument for read/write/command ioctls */
+typedef struct
+{
+	uint64_t buffer_ptr;
+	unsigned requested_transfer_count;
+	unsigned completed_transfer_count;
+	int end;
+	int handle;
+} read_write_ioctl_t;
+
+typedef struct
+{
+	unsigned int handle;
+	unsigned int pad;
+	int sad;
+	unsigned is_board : 1;
+} open_dev_ioctl_t;
+
+typedef struct
+{
+	unsigned int handle;
+} close_dev_ioctl_t;
+
+typedef struct
+{
+	unsigned int pad;
+	int sad;
+	uint8_t status_byte;
+} serial_poll_ioctl_t;
+
+typedef struct
+{
+	int eos;
+	int eos_flags;
+} eos_ioctl_t;
+
+typedef struct
+{
+	int handle;
+	int wait_mask;
+	int clear_mask;
+	int set_mask;
+	int ibsta;
+	int pad;
+	int sad;
+	unsigned usec_timeout;
+} wait_ioctl_t;
+
+typedef struct
+{
+	uint64_t init_data_ptr;
+	int init_data_length;
+	int online;
+} online_ioctl_t;
+
+typedef struct
+{
+	unsigned int num_bytes;
+	unsigned int pad;
+	int sad;
+} spoll_bytes_ioctl_t;
+
+typedef struct
+{
+	unsigned int pad;
+	int sad;
+	int parallel_poll_configuration;
+	int autopolling;
+	int is_system_controller;
+	unsigned int t1_delay;
+	unsigned ist : 1;
+	unsigned no_7_bit_eos : 1;
+} board_info_ioctl_t;
+
+typedef struct
+{
+	int pci_bus;
+	int pci_slot;
+} select_pci_ioctl_t;
+
+typedef struct
+{
+	uint8_t config;
+	unsigned set_ist : 1;
+	unsigned clear_ist : 1;
+}	ppoll_config_ioctl_t;
+
+typedef struct
+{
+	unsigned int handle;
+	unsigned int pad;
+} pad_ioctl_t;
+
+typedef struct
+{
+	unsigned int handle;
+	int sad;
+} sad_ioctl_t;
+
+typedef short event_ioctl_t;
+typedef int rsc_ioctl_t;
+typedef unsigned int t1_delay_ioctl_t;
+typedef short autospoll_ioctl_t;
+
+/* Standard functions. */
+enum gpib_ioctl
+{
+	IBRD = _IOWR( GPIB_CODE, 100, read_write_ioctl_t ),
+	IBWRT = _IOWR( GPIB_CODE, 101, read_write_ioctl_t ),
+	IBCMD = _IOWR( GPIB_CODE, 102, read_write_ioctl_t ),
+	IBOPENDEV = _IOWR( GPIB_CODE, 3, open_dev_ioctl_t ),
+	IBCLOSEDEV = _IOW( GPIB_CODE, 4, close_dev_ioctl_t ),
+	IBWAIT = _IOWR( GPIB_CODE, 5, wait_ioctl_t ),
+	IBRPP = _IOWR( GPIB_CODE, 6, uint8_t ),
+
+	IBSIC = _IOW( GPIB_CODE, 9, unsigned int ),
+	IBSRE = _IOW( GPIB_CODE, 10, int ),
+	IBGTS = _IO( GPIB_CODE, 11 ),
+	IBCAC = _IOW( GPIB_CODE, 12, int ),
+	IBLINES = _IOR( GPIB_CODE, 14, short ),
+	IBPAD = _IOW( GPIB_CODE, 15, pad_ioctl_t ),
+	IBSAD = _IOW( GPIB_CODE, 16, sad_ioctl_t ),
+	IBTMO = _IOW( GPIB_CODE, 17, unsigned int ),
+	IBRSP = _IOWR( GPIB_CODE, 18, serial_poll_ioctl_t ),
+	IBEOS = _IOW( GPIB_CODE, 19, eos_ioctl_t ),
+	IBRSV = _IOW( GPIB_CODE, 20, uint8_t ),
+	CFCBASE = _IOW( GPIB_CODE, 21, uint64_t ),
+	CFCIRQ = _IOW( GPIB_CODE, 22, unsigned int ),
+	CFCDMA = _IOW( GPIB_CODE, 23, unsigned int ),
+	CFCBOARDTYPE = _IOW( GPIB_CODE, 24, board_type_ioctl_t ),
+
+	IBMUTEX = _IOW( GPIB_CODE, 26, int ),
+	IBSPOLL_BYTES = _IOWR( GPIB_CODE, 27, spoll_bytes_ioctl_t ),
+	IBPPC = _IOW( GPIB_CODE, 28, ppoll_config_ioctl_t ),
+	IBBOARD_INFO = _IOR( GPIB_CODE, 29, board_info_ioctl_t ),
+
+	IBQUERY_BOARD_RSV = _IOR( GPIB_CODE, 31, int ),
+	IBSELECT_PCI = _IOWR( GPIB_CODE, 32, select_pci_ioctl_t ),
+	IBEVENT = _IOR( GPIB_CODE, 33, event_ioctl_t ),
+	IBRSC = _IOW( GPIB_CODE, 34, rsc_ioctl_t ),
+	IB_T1_DELAY = _IOW( GPIB_CODE, 35, t1_delay_ioctl_t ),
+	IBLOC = _IO( GPIB_CODE, 36 ),
+
+	IBAUTOSPOLL = _IOW( GPIB_CODE, 38, autospoll_ioctl_t ),
+	IBONL = _IOW( GPIB_CODE, 39, online_ioctl_t )
+};
+
+#endif	/* _GPIB_IOCTL_H */
diff --git a/drivers/gpib/include/gpib_proto.h b/drivers/gpib/include/gpib_proto.h
new file mode 100644
index 0000000..83234e3
--- /dev/null
+++ b/drivers/gpib/include/gpib_proto.h
@@ -0,0 +1,55 @@
+
+#ifndef GPIB_PROTO_INCLUDED
+#define GPIB_PROTO_INCLUDED
+
+#include <linux/fs.h>
+
+int ibopen( struct inode *inode, struct file *filep );
+int ibclose( struct inode *inode, struct file *file );
+long ibioctl(struct file *filep, unsigned int cmd, unsigned long arg );
+int osInit( void );
+void osReset( void );
+void watchdog_timeout( unsigned long arg );
+void osStartTimer( gpib_board_t *board, unsigned int usec_timeout );
+void osRemoveTimer( gpib_board_t *board );
+void osSendEOI( void );
+void osSendEOI( void );
+void init_gpib_board( gpib_board_t *board );
+static inline unsigned long usec_to_jiffies(unsigned int usec)
+{
+	unsigned long usec_per_jiffy = 1000000 / HZ;
+
+	return 1 + ( usec + usec_per_jiffy - 1) / usec_per_jiffy;
+};
+int serial_poll_all( gpib_board_t *board, unsigned int usec_timeout );
+void init_gpib_descriptor( gpib_descriptor_t *desc );
+int dvrsp(gpib_board_t *board, unsigned int pad, int sad,
+	unsigned int usec_timeout, uint8_t *result );
+int ibAPWait(gpib_board_t *board, int pad);
+int ibAPrsp(gpib_board_t *board, int padsad, char *spb);
+void ibAPE(gpib_board_t *board, int pad, int v);
+int ibcac(gpib_board_t *board, int sync);
+ssize_t ibcmd( gpib_board_t *board, uint8_t *buf, size_t length );
+int ibgts(gpib_board_t *board);
+int ibonline(gpib_board_t *board, gpib_board_config_t config);
+int iboffline( gpib_board_t *board );
+int iblines( const gpib_board_t *board, short *lines );
+int ibrd(gpib_board_t *board, uint8_t *buf, size_t length, int *end_flag, size_t *bytes_read);
+int ibrpp( gpib_board_t *board, uint8_t *buf );
+int ibrsv(gpib_board_t *board, uint8_t poll_status);
+void ibrsc( gpib_board_t *board, int request_control );
+int ibsic( gpib_board_t *board, unsigned int usec_duration );
+int ibsre(gpib_board_t *board, int enable);
+int ibpad( gpib_board_t *board, unsigned int addr );
+int ibsad( gpib_board_t *board, int addr );
+int ibeos( gpib_board_t *board, int eos, int eosflags );
+int ibwait(gpib_board_t *board, int wait_mask, int clear_mask, int set_mask,
+	int *status, unsigned long usec_timeout, gpib_descriptor_t *desc );
+int ibwrt(gpib_board_t *board, uint8_t *buf, size_t cnt, int send_eoi, size_t *bytes_written);
+int ibstatus( gpib_board_t *board );
+int general_ibstatus( gpib_board_t *board, const gpib_status_queue_t *device,
+	int clear_mask, int set_mask, gpib_descriptor_t *desc );
+int io_timed_out( gpib_board_t *board );
+int ibppc( gpib_board_t *board, uint8_t configuration );
+
+#endif /* GPIB_PROTO_INCLUDED */
diff --git a/drivers/gpib/include/gpib_state_machines.h b/drivers/gpib/include/gpib_state_machines.h
new file mode 100644
index 0000000..e0692a8
--- /dev/null
+++ b/drivers/gpib/include/gpib_state_machines.h
@@ -0,0 +1,36 @@
+/***************************************************************************
+                                   gpib_state_machines.h
+                             -------------------
+    begin                : June 2006
+    copyright            : (C) 2006 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _GPIB_STATE_MACHINES_H
+#define _GPIB_STATE_MACHINES_H
+
+enum talker_function_state
+{
+	talker_idle,
+	talker_addressed,
+	talker_active,
+	serial_poll_active
+};
+
+enum listener_function_state
+{
+	listener_idle,
+	listener_addressed,
+	listener_active
+};
+
+#endif	// _GPIB_STATE_MACHINES_H
diff --git a/drivers/gpib/include/gpib_types.h b/drivers/gpib/include/gpib_types.h
new file mode 100644
index 0000000..c83b5ec
--- /dev/null
+++ b/drivers/gpib/include/gpib_types.h
@@ -0,0 +1,315 @@
+/***************************************************************************
+                                gpib_types.h
+                             -------------------
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _GPIB_TYPES_H
+#define _GPIB_TYPES_H
+
+#ifdef __KERNEL__
+/* gpib_interface_t defines the interface
+ * between the board-specific details dealt with in the drivers
+ * and generic interface provided by gpib-common.
+ * This really should be in a different header file.
+ */
+#include "gpib_user.h"
+#include <asm/atomic.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+
+typedef struct gpib_interface_struct gpib_interface_t;
+typedef struct gpib_board_struct gpib_board_t;
+
+typedef struct
+{
+	void *init_data;
+	int init_data_length;
+} gpib_board_config_t;
+
+struct gpib_interface_struct
+{
+	/* name of board */
+	char *name;
+	/* attach() initializes board and allocates resources */
+	int (*attach)(gpib_board_t *board, gpib_board_config_t config);
+	/* detach() shuts down board and frees resources */
+	void (*detach)(gpib_board_t *board);
+	/* read() should read at most 'length' bytes from the bus into
+	 * 'buffer'.  It should return when it fills the buffer or
+	 * encounters an END (EOI and or EOS if appropriate).  It should set 'end'
+	 * to be nonzero if the read was terminated by an END, otherwise 'end'
+	 * should be zero.
+	 * Ultimately, this will be changed into or replaced by an asynchronous
+	 * read.  Zero return value for success, negative
+	 * return indicates error.
+         * nbytes returns number of bytes read
+	 */
+	int (*read)(gpib_board_t *board, uint8_t *buffer, size_t length, int *end, size_t *bytes_read);
+	/* write() should write 'length' bytes from buffer to the bus.
+	 * If the boolean value send_eoi is nonzero, then EOI should
+	 * be sent along with the last byte.  Returns number of bytes
+	 * written or negative value on error.
+	 */
+	int (*write)(gpib_board_t *board, uint8_t *buffer, size_t length, int send_eoi, size_t *bytes_written);
+	/* command() writes the command bytes in 'buffer' to the bus
+	 * Returns number of bytes written or negative value on error.
+	 */
+	ssize_t (*command)(gpib_board_t *board, uint8_t *buffer, size_t length);
+	/* Take control (assert ATN).  If 'asyncronous' is nonzero, take
+	 * control asyncronously (assert ATN immediately without waiting
+	 * for other processes to complete first).  Should not return
+	 * until board becomes controller in charge.  Returns zero no success,
+	 * nonzero on error.
+	 */
+	int (*take_control)(gpib_board_t *board, int asyncronous);
+	/* De-assert ATN.  Returns zero on success, nonzer on error.
+	 */
+	int (*go_to_standby)(gpib_board_t *board);
+	/* request/release control of the IFC and REN lines (system controller) */
+	void ( *request_system_control )( gpib_board_t *board, int request_control );
+	/* Asserts or de-asserts 'interface clear' (IFC) depending on
+	 * boolean value of 'assert'
+	 */
+	void (*interface_clear)(gpib_board_t *board, int assert);
+	/* Sends remote enable command if 'enable' is nonzero, disables remote mode
+	 * if 'enable' is zero
+	 */
+	void (*remote_enable)(gpib_board_t *board, int enable);
+	/* enable END for reads, when byte 'eos' is received.  If
+	 * 'compare_8_bits' is nonzero, then all 8 bits are compared
+	 * with the eos bytes.  Otherwise only the 7 least significant
+	 * bits are compared. */
+	int (*enable_eos)(gpib_board_t *board, uint8_t eos, int compare_8_bits);
+	/* disable END on eos byte (END on EOI only)*/
+	void (*disable_eos)(gpib_board_t *board);
+	/* configure parallel poll */
+	void (*parallel_poll_configure)( gpib_board_t *board, uint8_t configuration );
+	/* conduct parallel poll */
+	int (*parallel_poll)(gpib_board_t *board, uint8_t *result);
+	/* set/clear ist (individual status bit) */
+	void (*parallel_poll_response)( gpib_board_t *board, int ist );
+	/* Returns current status of the bus lines.  Should be set to
+	 * NULL if your board does not have the ability to query the
+	 * state of the bus lines. */
+	int ( *line_status )( const gpib_board_t *board );
+	/* updates and returns the board's current status.
+	 * The meaning of the bits are specified in gpib_user.h
+	 * in the IBSTA section.  The driver does not need to
+	 * worry about setting the CMPL, END, TIMO, or ERR bits.
+	 */
+	unsigned int (*update_status)( gpib_board_t *board, unsigned int clear_mask );
+	/* Sets primary address 0-30 for gpib interface card.
+	 */
+	void (*primary_address)(gpib_board_t *board, unsigned int address);
+	/* Sets and enables, or disables secondary address 0-30
+	 * for gpib interface card.
+	 */
+	void (*secondary_address)(gpib_board_t *board, unsigned int address,
+	int enable);
+	/* Sets the byte the board should send in response to a serial poll.
+	 * Function should also request service if appropriate.
+	 */
+	void (*serial_poll_response)(gpib_board_t *board, uint8_t status);
+	/* returns the byte the board will send in response to a serial poll.
+	 */
+	uint8_t ( *serial_poll_status )( gpib_board_t *board );
+	/* adjust T1 delay */
+	unsigned int ( *t1_delay )( gpib_board_t *board, unsigned int nano_sec );
+	/* go to local mode */
+	void ( *return_to_local )( gpib_board_t *board );
+	/* board does not support 7 bit eos comparisons */
+	unsigned no_7_bit_eos : 1;
+};
+
+typedef struct
+{
+	struct list_head event_head;
+	spinlock_t lock;
+	unsigned int num_events;
+	unsigned dropped_event : 1;
+} gpib_event_queue_t;
+
+static inline void init_event_queue( gpib_event_queue_t *queue )
+{
+	INIT_LIST_HEAD( &queue->event_head );
+	queue->num_events = 0;
+	queue->dropped_event = 0;
+	spin_lock_init( &queue->lock );
+}
+
+/* struct for supporting polling operation when irq is not available */
+struct gpib_pseudo_irq
+{
+	struct timer_list timer;
+	irqreturn_t (*handler)(int, void * PT_REGS_ARG);
+	atomic_t active;
+};
+
+static inline void init_gpib_pseudo_irq( struct gpib_pseudo_irq *pseudo_irq)
+{
+	pseudo_irq->handler = NULL;
+	init_timer(&pseudo_irq->timer);
+	atomic_set(&pseudo_irq->active, 0);
+}
+
+/* list so we can make a linked list of drivers */
+typedef struct gpib_interface_list_struct
+{
+	struct list_head list;
+	gpib_interface_t *interface;
+	struct module *module;
+} gpib_interface_list_t;
+
+/* One gpib_board_t is allocated for each physical board in the computer.
+ * It provides storage for variables local to each board, and interface
+ * functions for performing operations on the board */
+struct gpib_board_struct
+{
+	/* functions used by this board */
+	gpib_interface_t *interface;
+	/* Pointer to module whose use count we should increment when
+	 * interface is in use */
+	struct module *provider_module;
+	/* buffer used to store read/write data for this board */
+	uint8_t *buffer;
+	/* length of buffer */
+	unsigned int buffer_length;
+	/* Used to hold the board's current status (see update_status() above)
+	 */
+	volatile unsigned long status;
+	/* Driver should only sleep on this wait queue.  It is special in that the
+	 * core will wake this queue and set the TIMO bit in 'status' when the
+	 * watchdog timer times out.
+	 */
+	wait_queue_head_t wait;
+	/* Lock that only allows one process to access this board at a time.
+	   Has to be first in any locking order, since it can be locked over
+	   multiple ioctls. */
+	struct mutex user_mutex;
+	/* Mutex which compensates for removal of "big kernel lock" from kernel.
+	   Should not be held for extended waits. */
+	struct mutex big_gpib_mutex;
+	/* pid of last process to lock the board mutex */
+	pid_t locking_pid;
+	spinlock_t locking_pid_spinlock;
+	/* Spin lock for dealing with races with the interrupt handler */
+	spinlock_t spinlock;
+	/* Watchdog timer to enable timeouts */
+	struct timer_list timer;
+	/* IO base address to use for non-pnp cards (set by core, driver should make local copy) */
+	void *ibbase;
+	/* IRQ to use for non-pnp cards (set by core, driver should make local copy) */
+	unsigned int ibirq;
+	/* dma channel to use for non-pnp cards (set by core, driver should make local copy) */
+	unsigned int ibdma;
+	/* pci bus of card, useful for distinguishing multiple identical pci cards
+	 * (negative means don't care) */
+	int pci_bus;
+	/* pci slot of card, useful for distinguishing multiple identical pci cards
+	 * (negative means don't care) */
+	int pci_slot;
+	/* 'private_data' can be used as seen fit by the driver to
+	 * store additional variables for this board */
+	void *private_data;
+	/* Number of open file descriptors using this board */
+	unsigned int use_count;
+	/* list of open devices connected to this board */
+	struct list_head device_list;
+	/* primary address */
+	unsigned int pad;
+	/* secondary address */
+	int sad;
+	/* timeout for io operations, in microseconds */
+	unsigned int usec_timeout;
+	/* board's parallel poll configuration byte */
+	uint8_t parallel_poll_configuration;
+	/* t1 delay we are using */
+	unsigned int t1_nano_sec;
+	/* Count that keeps track of whether board is up and running or not */
+	unsigned int online;
+	/* number of processes trying to autopoll */
+	int autospollers;
+	/* autospoll kernel thread */
+	struct task_struct *autospoll_task;
+	/* queue for recording received trigger/clear/ifc events */
+	gpib_event_queue_t event_queue;
+	/* minor number for this board's device file */
+	int minor;
+	/* struct to deal with polling mode*/
+	struct gpib_pseudo_irq pseudo_irq;
+	/* error dong autopoll */
+	atomic_t stuck_srq;
+	/* Flag that indicates whether board is system controller of the bus */
+	unsigned master : 1;
+	/* individual status bit */
+	unsigned ist : 1;
+};
+
+/* element of event queue */
+typedef struct
+{
+	struct list_head list;
+	short event_type;
+} gpib_event_t;
+
+/* Each board has a list of gpib_status_queue_t to keep track of all open devices
+ * on the bus, so we know what address to poll when we get a service request */
+typedef struct
+{
+	/* list_head so we can make a linked list of devices */
+	struct list_head list;
+	unsigned int pad;	/* primary gpib address */
+	int sad;	/* secondary gpib address (negative means disabled) */
+	/* stores serial poll bytes for this device */
+	struct list_head status_bytes;
+	unsigned int num_status_bytes;
+	/* number of times this address is opened */
+	unsigned int reference_count;
+	/* flags loss of status byte error due to limit on size of queue */
+	unsigned dropped_byte : 1;
+} gpib_status_queue_t;
+
+typedef struct
+{
+	struct list_head list;
+	uint8_t poll_byte;
+} status_byte_t;
+
+void init_gpib_status_queue( gpib_status_queue_t *device );
+
+/* Used to store device-descriptor-specific information */
+typedef struct
+{
+	unsigned int pad;	/* primary gpib address */
+	int sad;	/* secondary gpib address (negative means disabled) */
+	atomic_t io_in_progress;
+	unsigned is_board : 1;
+} gpib_descriptor_t;
+
+typedef struct
+{
+	atomic_t holding_mutex;
+	gpib_descriptor_t *descriptors[ GPIB_MAX_NUM_DESCRIPTORS ];
+	/* locked while descriptors are being allocated/deallocated */
+	struct mutex descriptors_mutex;
+	unsigned got_module : 1;
+} gpib_file_private_t;
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _GPIB_TYPES_H */
diff --git a/drivers/gpib/include/gpib_user.h b/drivers/gpib/include/gpib_user.h
new file mode 100644
index 0000000..d036846
--- /dev/null
+++ b/drivers/gpib/include/gpib_user.h
@@ -0,0 +1,322 @@
+/***************************************************************************
+                          gpib_user.h  -  header file for gpib library
+                             -------------------
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef _GPIB_USER_H
+#define _GPIB_USER_H
+
+#define GPIB_MAX_NUM_BOARDS 16
+#define GPIB_MAX_NUM_DESCRIPTORS 0x1000
+
+enum ibsta_bit_numbers
+{
+	DCAS_NUM = 0,
+	DTAS_NUM = 1,
+	LACS_NUM = 2,
+	TACS_NUM = 3,
+	ATN_NUM = 4,
+	CIC_NUM = 5,
+	REM_NUM = 6,
+	LOK_NUM = 7,
+	CMPL_NUM = 8,
+	EVENT_NUM = 9,
+	SPOLL_NUM = 10,
+	RQS_NUM = 11,
+	SRQI_NUM = 12,
+	END_NUM = 13,
+	TIMO_NUM = 14,
+	ERR_NUM = 15
+};
+
+/* IBSTA status bits (returned by all functions) */
+enum ibsta_bits
+{
+	DCAS = ( 1 << DCAS_NUM ),	/* device clear state */
+	DTAS = ( 1 << DTAS_NUM ),	/* device trigger state */
+	LACS = ( 1 <<  LACS_NUM ),	/* GPIB interface is addressed as Listener */
+	TACS = ( 1 <<  TACS_NUM ),	/* GPIB interface is addressed as Talker */
+	ATN = ( 1 <<  ATN_NUM ),	/* Attention is asserted */
+	CIC = ( 1 <<  CIC_NUM ),	/* GPIB interface is Controller-in-Charge */
+	REM = ( 1 << REM_NUM ),	/* remote state */
+	LOK = ( 1 << LOK_NUM ),	/* lockout state */
+	CMPL = ( 1 <<  CMPL_NUM ),	/* I/O is complete  */
+	EVENT = ( 1 << EVENT_NUM ),	/* DCAS, DTAS, or IFC has occurred */
+	SPOLL = ( 1 << SPOLL_NUM ),	/* board serial polled by busmaster */
+	RQS = ( 1 <<  RQS_NUM ),	/* Device requesting service  */
+	SRQI = ( 1 << SRQI_NUM ),	/* SRQ is asserted */
+	END = ( 1 << END_NUM ),	/* EOI or EOS encountered */
+	TIMO = ( 1 << TIMO_NUM ),	/* Time limit on I/O or wait function exceeded */
+	ERR = ( 1 << ERR_NUM )	/* Function call terminated on error */
+};
+
+static const int device_status_mask = ERR | TIMO | END | CMPL | RQS;
+static const int board_status_mask = ERR | TIMO | END | CMPL | SPOLL |
+	EVENT | LOK | REM | CIC | ATN | TACS | LACS | DTAS | DCAS | SRQI;
+
+/* IBERR error codes */
+enum iberr_code
+{
+	EDVR = 0,		/* system error */
+	ECIC = 1,	/* not CIC */
+	ENOL = 2,		/* no listeners */
+	EADR = 3,		/* CIC and not addressed before I/O */
+	EARG = 4,		/* bad argument to function call */
+	ESAC = 5,		/* not SAC */
+	EABO = 6,		/* I/O operation was aborted */
+	ENEB = 7,		/* non-existent board (GPIB interface offline) */
+	EDMA = 8,		/* DMA hardware error detected */
+	EOIP = 10,		/* new I/O attempted with old I/O in progress  */
+	ECAP = 11,		/* no capability for intended opeation */
+	EFSO = 12,		/* file system operation error */
+	EBUS = 14,		/* bus error */
+	ESTB = 15,		/* lost serial poll bytes */
+	ESRQ = 16,		/* SRQ stuck on */
+	ETAB = 20              /* Table Overflow */
+};
+/* Timeout values and meanings */
+
+enum gpib_timeout
+{
+	TNONE = 0,		/* Infinite timeout (disabled)     */
+	T10us = 1,		/* Timeout of 10 usec (ideal)      */
+	T30us = 2,		/* Timeout of 30 usec (ideal)      */
+	T100us = 3,		/* Timeout of 100 usec (ideal)     */
+	T300us = 4,		/* Timeout of 300 usec (ideal)     */
+	T1ms = 5,		/* Timeout of 1 msec (ideal)       */
+	T3ms = 6,		/* Timeout of 3 msec (ideal)       */
+	T10ms = 7,		/* Timeout of 10 msec (ideal)      */
+	T30ms = 8,		/* Timeout of 30 msec (ideal)      */
+	T100ms = 9,		/* Timeout of 100 msec (ideal)     */
+	T300ms = 10,	/* Timeout of 300 msec (ideal)     */
+	T1s = 11,		/* Timeout of 1 sec (ideal)        */
+	T3s = 12,		/* Timeout of 3 sec (ideal)        */
+	T10s = 13,		/* Timeout of 10 sec (ideal)       */
+	T30s = 14,		/* Timeout of 30 sec (ideal)       */
+	T100s = 15,		/* Timeout of 100 sec (ideal)      */
+	T300s = 16,		/* Timeout of 300 sec (ideal)      */
+	T1000s = 17		/* Timeout of 1000 sec (maximum)   */
+};
+
+/* End-of-string (EOS) modes for use with ibeos */
+
+enum eos_flags
+{
+	EOS_MASK = 0x1c00,
+	REOS = 0x0400,		/* Terminate reads on EOS	*/
+	XEOS = 0x800,	/* assert EOI when EOS char is sent */
+	BIN = 0x1000		/* Do 8-bit compare on EOS	*/
+};
+
+/* GPIB Bus Control Lines bit vector */
+enum bus_control_line
+{
+	ValidDAV = 0x01,
+	ValidNDAC = 0x02,
+	ValidNRFD = 0x04,
+	ValidIFC = 0x08,
+	ValidREN = 0x10,
+	ValidSRQ = 0x20,
+	ValidATN = 0x40,
+	ValidEOI = 0x80,
+	ValidALL = 0xff,
+	BusDAV = 0x0100,		/* DAV  line status bit */
+	BusNDAC = 0x0200,		/* NDAC line status bit */
+	BusNRFD = 0x0400,		/* NRFD line status bit */
+	BusIFC = 0x0800,		/* IFC  line status bit */
+	BusREN = 0x1000,		/* REN  line status bit */
+	BusSRQ = 0x2000,		/* SRQ  line status bit */
+	BusATN = 0x4000,		/* ATN  line status bit */
+	BusEOI = 0x8000		/* EOI  line status bit */
+};
+
+enum old_bus_control_line
+{
+	BUS_DAV = 0x0100,		/* DAV  line status bit */
+	BUS_NDAC = 0x0200,		/* NDAC line status bit */
+	BUS_NRFD = 0x0400,		/* NRFD line status bit */
+	BUS_IFC = 0x0800,		/* IFC  line status bit */
+	BUS_REN = 0x1000,		/* REN  line status bit */
+	BUS_SRQ = 0x2000,		/* SRQ  line status bit */
+	BUS_ATN = 0x4000,		/* ATN  line status bit */
+	BUS_EOI = 0x8000		/* EOI  line status bit */
+};
+
+
+/* Possible GPIB command messages */
+
+enum cmd_byte
+{
+	GTL = 0x1,	/* go to local			*/
+	SDC = 0x4,	/* selected device clear 	*/
+	PPConfig = 0x5,
+#ifndef PPC
+	PPC = PPConfig,	/* parallel poll configure	*/
+#endif
+	GET = 0x8,	/* group execute trigger 	*/
+	TCT = 0x9,	/* take control 		*/
+	LLO = 0x11,	/* local lockout		*/
+	DCL = 0x14,	/* device clear 		*/
+	PPU = 0x15,	/* parallel poll unconfigure 	*/
+	SPE = 0x18,	/* serial poll enable 		*/
+	SPD = 0x19,	/* serial poll disable 		*/
+	LAD = 0x20,	/* value to be 'ored' in to obtain listen address */
+	UNL = 0x3F,	/* unlisten 			*/
+	TAD = 0x40,	/* value to be 'ored' in to obtain talk address   */
+	UNT = 0x5F,	/* untalk 			*/
+	SAD = 0x60,	/* my secondary address (base) */
+	PPE = 0x60,	/* parallel poll enable (base)	*/
+	PPD = 0x70	/* parallel poll disable	*/
+};
+
+enum ppe_bits
+{
+	PPC_DISABLE = 0x10,
+	PPC_SENSE = 0x8,	/* parallel poll sense bit	*/
+	PPC_DIO_MASK = 0x7
+};
+
+static __inline__ uint8_t MLA( unsigned int addr )
+{
+	return addr | LAD;
+}
+
+static __inline__ uint8_t MTA( unsigned int addr )
+{
+	return addr | TAD;
+}
+
+static __inline__ uint8_t MSA( unsigned int addr )
+{
+	return addr | SAD;
+}
+
+static __inline__ uint8_t PPE_byte( unsigned int dio_line, int sense )
+{
+	uint8_t cmd;
+
+	cmd = PPE;
+	if( sense )
+		cmd |= PPC_SENSE;
+	cmd |= ( dio_line - 1 ) & 0x7;
+	return cmd;
+}
+
+static __inline__ int gpib_address_equal( unsigned int pad1, int sad1, unsigned int pad2, int sad2 )
+{
+	if( pad1 == pad2 )
+	{
+		if( sad1 == sad2 ) return 1;
+		if( sad1 < 0 && sad2 < 0 ) return 1;
+	}
+
+	return 0;
+}
+
+static const int gpib_addr_max = 30;	/* max address for primary/secondary gpib addresses */
+
+enum ibask_option
+{
+	IbaPAD = 0x1,
+	IbaSAD = 0x2,
+	IbaTMO = 0x3,
+	IbaEOT = 0x4,
+	IbaPPC = 0x5,	/* board only */
+	IbaREADDR = 0x6,	/* device only */
+	IbaAUTOPOLL = 0x7,	/* board only */
+	IbaCICPROT = 0x8,	/* board only */
+	IbaIRQ = 0x9,	/* board only */
+	IbaSC = 0xa,	/* board only */
+	IbaSRE = 0xb,	/* board only */
+	IbaEOSrd = 0xc,
+	IbaEOSwrt = 0xd,
+	IbaEOScmp = 0xe,
+	IbaEOSchar = 0xf,
+	IbaPP2 = 0x10,	/* board only */
+	IbaTIMING = 0x11,	/* board only */
+	IbaDMA = 0x12,	/* board only */
+	IbaReadAdjust = 0x13,
+	IbaWriteAdjust = 0x14,
+	IbaEventQueue = 0x15,	/* board only */
+	IbaSPollBit = 0x16,	/* board only */
+	IbaSpollBit = 0x16,	/* board only */
+	IbaSendLLO = 0x17,	/* board only */
+	IbaSPollTime = 0x18,	/* device only */
+	IbaPPollTime = 0x19,	/* board only */
+	IbaEndBitIsNormal = 0x1a,
+	IbaUnAddr = 0x1b,	/* device only */
+	IbaHSCableLength = 0x1f,	/* board only */
+	IbaIst = 0x20,	/* board only */
+	IbaRsv = 0x21,	/* board only */
+	IbaBNA = 0x200,	/* device only */
+	/* linux-gpib extensions */
+	Iba7BitEOS = 0x1000	/* board only. Returns 1 if board supports 7 bit eos compares*/
+};
+
+enum ibconfig_option
+{
+	IbcPAD = 0x1,
+	IbcSAD = 0x2,
+	IbcTMO = 0x3,
+	IbcEOT = 0x4,
+	IbcPPC = 0x5,	/* board only */
+	IbcREADDR = 0x6,	/* device only */
+	IbcAUTOPOLL = 0x7,	/* board only */
+	IbcCICPROT = 0x8,	/* board only */
+	IbcIRQ = 0x9,	/* board only */
+	IbcSC = 0xa,	/* board only */
+	IbcSRE = 0xb,	/* board only */
+	IbcEOSrd = 0xc,
+	IbcEOSwrt = 0xd,
+	IbcEOScmp = 0xe,
+	IbcEOSchar = 0xf,
+	IbcPP2 = 0x10,	/* board only */
+	IbcTIMING = 0x11,	/* board only */
+	IbcDMA = 0x12,	/* board only */
+	IbcReadAdjust = 0x13,
+	IbcWriteAdjust = 0x14,
+	IbcEventQueue = 0x15,	/* board only */
+	IbcSPollBit = 0x16,	/* board only */
+	IbcSpollBit = 0x16,	/* board only */
+	IbcSendLLO = 0x17,	/* board only */
+	IbcSPollTime = 0x18,	/* device only */
+	IbcPPollTime = 0x19,	/* board only */
+	IbcEndBitIsNormal = 0x1a,
+	IbcUnAddr = 0x1b,	/* device only */
+	IbcHSCableLength = 0x1f,	/* board only */
+	IbcIst = 0x20,	/* board only */
+	IbcRsv = 0x21,	/* board only */
+	IbcBNA = 0x200	/* device only */
+};
+
+enum t1_delays
+{
+	T1_DELAY_2000ns = 1,
+	T1_DELAY_500ns = 2,
+	T1_DELAY_350ns = 3
+};
+
+static const int request_service_bit = 0x40;
+
+enum gpib_events
+{
+	EventNone = 0,
+	EventDevTrg = 1,
+	EventDevClr = 2,
+	EventIFC = 3
+};
+
+#endif	/* _GPIB_USER_H */
diff --git a/drivers/gpib/include/nec7210.h b/drivers/gpib/include/nec7210.h
new file mode 100644
index 0000000..d86f4b3
--- /dev/null
+++ b/drivers/gpib/include/nec7210.h
@@ -0,0 +1,148 @@
+/***************************************************************************
+                                   nec7210.h
+                             -------------------
+    begin                : Jan 2002
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _NEC7210_H
+#define _NEC7210_H
+
+#include "gpib_state_machines.h"
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+
+#include "gpib_types.h"
+#include "nec7210_registers.h"
+
+/* struct used to provide variables local to a nec7210 chip */
+typedef struct nec7210_private_struct nec7210_private_t;
+struct nec7210_private_struct
+{
+	void *iobase;
+	unsigned int offset;	// offset between successive nec7210 io addresses
+	unsigned int dma_channel;
+	uint8_t *dma_buffer;
+	unsigned int dma_buffer_length;	// length of dma buffer
+	dma_addr_t dma_buffer_addr;	// bus address of board->buffer for use with dma
+	// software copy of bits written to registers
+	volatile uint8_t reg_bits[ 8 ];
+	volatile uint8_t auxa_bits;	// bits written to auxilliary register A
+	volatile uint8_t auxb_bits;	// bits written to auxilliary register B
+	// used to keep track of board's state, bit definitions given below
+	volatile unsigned long state;
+	/* lock for chips that extend the nec7210 registers by paging in alternate regs */
+	spinlock_t register_page_lock;
+	// wrappers for outb, inb, readb, or writeb
+	uint8_t (*read_byte)(nec7210_private_t *priv, unsigned int register_number);
+	void (*write_byte)(nec7210_private_t *priv, uint8_t byte, unsigned int register_number);
+	enum nec7210_chipset type;
+	enum talker_function_state talker_state;
+	enum listener_function_state listener_state;
+	void *private;
+	unsigned srq_pending : 1;
+};
+
+static inline void init_nec7210_private( nec7210_private_t *priv )
+{
+	memset( priv, 0, sizeof( nec7210_private_t ) );
+	spin_lock_init( &priv->register_page_lock );
+}
+
+// slightly shorter way to access read_byte and write_byte
+static inline uint8_t read_byte(nec7210_private_t *priv, unsigned int register_number)
+{
+	return priv->read_byte(priv, register_number);
+}
+static inline void write_byte(nec7210_private_t *priv, uint8_t byte, unsigned int register_number)
+{
+	priv->write_byte(priv, byte, register_number);
+}
+
+// nec7210_private_t.state bit numbers
+enum
+{
+	PIO_IN_PROGRESS_BN,	// pio transfer in progress
+	DMA_READ_IN_PROGRESS_BN,	// dma read transfer in progress
+	DMA_WRITE_IN_PROGRESS_BN,	// dma write transfer in progress
+	READ_READY_BN,	// board has data byte available to read
+	WRITE_READY_BN,	// board is ready to send a data byte
+	COMMAND_READY_BN,	// board is ready to send a command byte
+	RECEIVED_END_BN,	// received END
+	BUS_ERROR_BN,	// output error has occurred
+	RFD_HOLDOFF_BN,	// rfd holdoff in effect
+	DEV_CLEAR_BN,	// device clear received
+};
+
+// interface functions
+int nec7210_read(gpib_board_t *board, nec7210_private_t *priv,
+	uint8_t *buffer, size_t length, int *end, size_t *bytes_read);
+int nec7210_write(gpib_board_t *board, nec7210_private_t *priv,
+	uint8_t *buffer, size_t length, int send_eoi, size_t *bytes_written);
+ssize_t nec7210_command(gpib_board_t *board, nec7210_private_t *priv,
+	uint8_t *buffer, size_t length);
+int nec7210_take_control(gpib_board_t *board, nec7210_private_t *priv,
+	int syncronous);
+int nec7210_go_to_standby(gpib_board_t *board, nec7210_private_t *priv);
+void nec7210_request_system_control( gpib_board_t *board,
+	nec7210_private_t *priv, int request_control );
+void nec7210_interface_clear(gpib_board_t *board, nec7210_private_t *priv, int assert);
+void nec7210_remote_enable(gpib_board_t *board, nec7210_private_t *priv, int enable);
+int nec7210_enable_eos(gpib_board_t *board, nec7210_private_t *priv,
+	uint8_t eos_bytes, int compare_8_bits);
+void nec7210_disable_eos(gpib_board_t *board, nec7210_private_t *priv);
+unsigned int nec7210_update_status( gpib_board_t *board, nec7210_private_t *priv,
+	unsigned int clear_mask );
+void nec7210_primary_address( const gpib_board_t *board,
+	nec7210_private_t *priv, unsigned int address);
+void nec7210_secondary_address( const gpib_board_t *board, nec7210_private_t *priv,
+	unsigned int address, int enable);
+int nec7210_parallel_poll(gpib_board_t *board, nec7210_private_t *priv, uint8_t *result);
+void nec7210_serial_poll_response(gpib_board_t *board, nec7210_private_t *priv, uint8_t status);
+void nec7210_parallel_poll_configure( gpib_board_t *board,
+	nec7210_private_t *priv, unsigned int configuration );
+void nec7210_parallel_poll_response( gpib_board_t *board,
+	nec7210_private_t *priv, int ist );
+uint8_t nec7210_serial_poll_status( gpib_board_t *board,
+	nec7210_private_t *priv );
+unsigned int nec7210_t1_delay( gpib_board_t *board,
+	nec7210_private_t *priv, unsigned int nano_sec );
+void nec7210_return_to_local( const gpib_board_t *board, nec7210_private_t *priv );
+
+// utility functions
+void nec7210_board_reset( nec7210_private_t *priv, const gpib_board_t *board );
+void nec7210_board_online( nec7210_private_t *priv, const gpib_board_t *board );
+unsigned int nec7210_set_reg_bits( nec7210_private_t *priv, unsigned int reg,
+	unsigned int mask, unsigned int bits );
+void nec7210_set_handshake_mode( gpib_board_t *board, nec7210_private_t *priv, int mode );
+void nec7210_release_rfd_holdoff( gpib_board_t *board, nec7210_private_t *priv );
+uint8_t nec7210_read_data_in( gpib_board_t *board, nec7210_private_t *priv, int *end );
+
+// wrappers for io functions
+uint8_t nec7210_ioport_read_byte(nec7210_private_t *priv, unsigned int register_num);
+void nec7210_ioport_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num);
+uint8_t nec7210_iomem_read_byte(nec7210_private_t *priv, unsigned int register_num);
+void nec7210_iomem_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num);
+uint8_t nec7210_locking_ioport_read_byte(nec7210_private_t *priv, unsigned int register_num);
+void nec7210_locking_ioport_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num);
+uint8_t nec7210_locking_iomem_read_byte(nec7210_private_t *priv, unsigned int register_num);
+void nec7210_locking_iomem_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num);
+
+// interrupt service routine
+irqreturn_t nec7210_interrupt(gpib_board_t *board, nec7210_private_t *priv);
+irqreturn_t nec7210_interrupt_have_status( gpib_board_t *board,
+	nec7210_private_t *priv, int status1, int status2 );
+
+#endif	//_NEC7210_H
diff --git a/drivers/gpib/include/nec7210_registers.h b/drivers/gpib/include/nec7210_registers.h
new file mode 100644
index 0000000..9cc2a8f
--- /dev/null
+++ b/drivers/gpib/include/nec7210_registers.h
@@ -0,0 +1,243 @@
+/***************************************************************************
+                                   nec7210_registers.h
+                             -------------------
+    copyright            : (C) 2002 by Frank Mori Hess <fmhess@users.sourceforge.net>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _NEC7210_REGISTERS_H
+#define _NEC7210_REGISTERS_H
+
+enum nec7210_chipset
+{
+	NEC7210,	// The original
+	TNT4882,	// NI
+	NAT4882,	// NI
+	CB7210,	// measurement computing
+	IOT7210,	// iotech
+	iGPIB7210,	// Ines
+};
+
+// nec7210 has 8 registers
+static const int nec7210_num_registers = 8;
+
+/* nec7210 register numbers (might need to be multiplied by
+ * a board-dependent offset to get actually io address offset)
+ */
+// write registers
+enum nec7210_write_regs
+{
+	CDOR,	// command/data out
+	IMR1,	// interrupt mask 1
+	IMR2,	// interrupt mask 2
+	SPMR,	// serial poll mode
+	ADMR,	// address mode
+	AUXMR,	// auxilliary mode
+	ADR,	// address
+	EOSR,	// end-of-string
+};
+// read registers
+enum nec7210_read_regs
+{
+	DIR,	// data in
+	ISR1,	// interrupt status 1
+	ISR2,	// interrupt status 2
+	SPSR,	// serial poll status
+	ADSR,	// address status
+	CPTR,	// command pass though
+	ADR0,	// address 1
+	ADR1,	// address 2
+};
+
+//bit definitions common to nec-7210 compatible registers
+
+// ISR1: interrupt status register 1
+enum isr1_bits
+{
+	HR_DI = ( 1 << 0 ),
+	HR_DO = ( 1 << 1 ),
+	HR_ERR = ( 1 << 2 ),
+	HR_DEC = ( 1 << 3 ),
+	HR_END = ( 1 << 4 ),
+	HR_DET = ( 1 << 5 ),
+	HR_APT = ( 1 << 6 ),
+	HR_CPT = ( 1 << 7 ),
+};
+
+// IMR1: interrupt mask register 1
+enum imr1_bits
+{
+	HR_DIIE = ( 1 << 0 ),
+	HR_DOIE = ( 1 << 1 ),
+	HR_ERRIE = ( 1 << 2 ),
+	HR_DECIE = ( 1 << 3 ),
+	HR_ENDIE = ( 1 << 4 ),
+	HR_DETIE = ( 1 << 5 ),
+	HR_APTIE = ( 1 << 6 ),
+	HR_CPTIE = ( 1 << 7 ),
+};
+
+// ISR2, interrupt status register 2
+enum isr2_bits
+{
+	HR_ADSC = ( 1 << 0 ),
+	HR_REMC = ( 1 << 1 ),
+	HR_LOKC = ( 1 << 2 ),
+	HR_CO = ( 1 << 3 ),
+	HR_REM = ( 1 << 4 ),
+	HR_LOK = ( 1 << 5 ),
+	HR_SRQI = ( 1 << 6 ),
+	HR_INT = ( 1 << 7 ),
+};
+
+// IMR2, interrupt mask register 2
+enum imr2_bits
+{
+	// all the bits in this register that enable interrupts
+	IMR2_ENABLE_INTR_MASK = 0x4f,
+	HR_ACIE = ( 1 << 0 ),
+	HR_REMIE = ( 1 << 1 ),
+	HR_LOKIE = ( 1 << 2 ),
+	HR_COIE = ( 1 << 3 ),
+	HR_DMAI = ( 1 << 4 ),
+	HR_DMAO = ( 1 << 5 ),
+	HR_SRQIE = ( 1 << 6 ),
+};
+
+// SPSR, serial poll status register
+enum spsr_bits
+{
+	HR_PEND = ( 1 << 6 ),
+};
+
+// SPMR, serial poll mode register
+enum spmr_bits
+{
+	HR_RSV = ( 1 << 6 ),
+};
+
+// ADSR, address status register
+enum adsr_bits
+{
+	HR_MJMN = ( 1 << 0 ),
+	HR_TA = ( 1 << 1 ),
+	HR_LA = ( 1 << 2 ),
+	HR_TPAS = ( 1 << 3 ),
+	HR_LPAS = ( 1 << 4 ),
+	HR_SPMS = ( 1 << 5 ),
+	HR_NATN = ( 1 << 6 ),
+	HR_CIC = ( 1 << 7 ),
+};
+
+// ADMR, address mode register
+enum admr_bits
+{
+	HR_ADM0 = ( 1 << 0 ),
+	HR_ADM1 = ( 1 << 1 ),
+	HR_TRM0 = ( 1 << 4 ),
+	HR_TRM1 = ( 1 << 5 ),
+	HR_TRM_EOIOE_TRIG = 0,
+	HR_TRM_CIC_TRIG = HR_TRM0,
+	HR_TRM_CIC_EOIOE = HR_TRM1,
+	HR_TRM_CIC_PE = HR_TRM0 | HR_TRM1,
+	HR_LON = ( 1 << 6 ),
+	HR_TON = ( 1 << 7 ),
+};
+
+// ADR, bits used in address0, address1 and address0/1 registers
+enum adr_bits
+{
+	ADDRESS_MASK = 0x1f,	/* mask to specify lower 5 bits */
+	HR_DL = ( 1 << 5 ),
+	HR_DT = ( 1 << 6 ),
+	HR_ARS = ( 1 << 7 ),
+};
+
+// ADR1, address1 register
+enum adr1_bits
+{
+	HR_EOI = ( 1 << 7 ),
+};
+
+// AUXMR, auxiliary mode register
+enum auxmr_bits
+{
+	ICR = 0x20,
+	PPR = 0x60,
+	AUXRA = 0x80,
+	AUXRB = 0xa0,
+	AUXRE = 0xc0,
+};
+
+// auxra, auxiliary register A
+enum auxra_bits
+{
+	HR_HANDSHAKE_MASK = 0x3,
+	HR_HLDA = 0x1,
+	HR_HLDE = 0x2,
+	HR_LCM = 0x3,	/* auxra listen continuous */
+	HR_REOS = 0x4,
+	HR_XEOS = 0x8,
+	HR_BIN = 0x10,
+};
+
+// auxrb, auxiliary register B
+enum auxrb_bits
+{
+	HR_CPTE = ( 1 << 0 ),
+	HR_SPEOI = ( 1 << 1 ),
+	HR_TRI = ( 1 << 2 ),
+	HR_INV = ( 1 << 3 ),
+	HR_ISS = ( 1 << 4 ),
+};
+
+enum auxre_bits
+{
+	HR_DAC_HLD_DCAS = 0x1,	/* perform DAC holdoff on receiving clear */
+	HR_DAC_HLD_DTAS = 0x2,	/* perform DAC holdoff on receiving trigger */
+};
+
+// parallel poll register
+enum ppr_bits
+{
+	HR_PPS = ( 1 << 3 ),
+	HR_PPU = ( 1 << 4 ),
+};
+
+/* 7210 Auxiliary Commands */
+enum aux_cmds
+{
+	AUX_PON = 0x0,	/* Immediate Execute pon                  */
+	AUX_CPPF = 0x1,	/* Clear Parallel Poll Flag               */
+	AUX_CR = 0x2,	/* Chip Reset                             */
+	AUX_FH = 0x3,	/* Finish Handshake                       */
+	AUX_TRIG = 0x4,	/* Trigger                                */
+	AUX_RTL = 0x5,	/* Return to local                        */
+	AUX_SEOI = 0x6,	/* Send EOI                               */
+	AUX_NVAL = 0x7,	/* Non-Valid Secondary Command or Address */
+	AUX_SPPF = 0x9,	/* Set Parallel Poll Flag                 */
+	AUX_VAL = 0xf,	/* Valid Secondary Command or Address     */
+	AUX_GTS = 0x10,	/* Go To Standby                          */
+	AUX_TCA = 0x11,	/* Take Control Asynchronously            */
+	AUX_TCS = 0x12,	/* Take Control Synchronously             */
+	AUX_LTN = 0x13,	/* Listen                                 */
+	AUX_DSC = 0x14,	/* Disable System Control                 */
+	AUX_CIFC = 0x16,	/* Clear IFC                              */
+	AUX_CREN = 0x17,	/* Clear REN                              */
+	AUX_TCSE = 0x1a,	/* Take Control Synchronously on End      */
+	AUX_LTNC = 0x1b,	/* Listen in Continuous Mode              */
+	AUX_LUN = 0x1c,	/* Local Unlisten                         */
+	AUX_EPP = 0x1d,	/* Execute Parallel Poll                  */
+	AUX_SIFC = 0x1e,	/* Set IFC                                */
+	AUX_SREN = 0x1f,	/* Set REN                                */
+};
+
+#endif	//_NEC7210_REGISTERS_H
diff --git a/drivers/gpib/include/plx9050.h b/drivers/gpib/include/plx9050.h
new file mode 100644
index 0000000..09b14b9
--- /dev/null
+++ b/drivers/gpib/include/plx9050.h
@@ -0,0 +1,85 @@
+/***************************************************************************
+                          plx9050.h  -  description
+                             -------------------
+  Header for plx9050 pci chip
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _PLX9050_GPIB_H
+#define _PLX9050_GPIB_H
+
+// plx pci chip registers and bits
+enum
+{
+	PLX9050_INTCSR_REG = 0x4c,
+	PLX9050_CNTRL_REG = 0x50
+};
+
+enum plx9050_intcsr_bits
+{
+	PLX9050_LINTR1_EN_BIT = 0x1,
+	PLX9050_LINTR1_POLARITY_BIT = 0x2,
+	PLX9050_LINTR1_STATUS_BIT = 0x4,
+	PLX9050_LINTR2_EN_BIT = 0x8,
+	PLX9050_LINTR2_POLARITY_BIT = 0x10,
+	PLX9050_LINTR2_STATUS_BIT = 0x20,
+	PLX9050_PCI_INTR_EN_BIT = 0x40,
+	PLX9050_SOFT_INTR_BIT = 0x80,
+	PLX9050_LINTR1_SELECT_ENABLE_BIT = 0x100,	//9052 extension
+	PLX9050_LINTR2_SELECT_ENABLE_BIT = 0x200,	//9052 extension
+	PLX9050_LINTR1_EDGE_CLEAR_BIT = 0x400,	//9052 extension
+	PLX9050_LINTR2_EDGE_CLEAR_BIT = 0x800,	//9052 extension
+};
+
+enum plx9050_cntrl_bits
+{
+	PLX9050_WAITO_NOT_USER0_SELECT_BIT = 0x1,
+	PLX9050_USER0_OUTPUT_BIT = 0x2,
+	PLX9050_USER0_DATA_BIT = 0x4,
+	PLX9050_LLOCK_NOT_USER1_SELECT_BIT = 0x8,
+	PLX9050_USER1_OUTPUT_BIT = 0x10,
+	PLX9050_USER1_DATA_BIT = 0x20,
+	PLX9050_CS2_NOT_USER2_SELECT_BIT = 0x40,
+	PLX9050_USER2_OUTPUT_BIT = 0x80,
+	PLX9050_USER2_DATA_BIT = 0x100,
+	PLX9050_CS3_NOT_USER3_SELECT_BIT = 0x200,
+	PLX9050_USER3_OUTPUT_BIT = 0x400,
+	PLX9050_USER3_DATA_BIT = 0x800,
+	PLX9050_PCIBAR_ENABLE_MASK = 0x3000,
+	PLX9050_PCIBAR_MEMORY_AND_IO_ENABLE_BITS = 0x0,
+	PLX9050_PCIBAR_MEMORY_NO_IO_ENABLE_BITS = 0x1000,
+	PLX9050_PCIBAR_IO_NO_MEMORY_ENABLE_BITS = 0x2000,
+	PLX9050_PCIBAR_MEMORY_AND_IO_TOO_ENABLE_BITS = 0x3000,
+	PLX9050_PCI_READ_MODE_BIT = 0x4000,
+	PLX9050_PCI_READ_WITH_WRITE_FLUSH_MODE_BIT = 0x8000,
+	PLX9050_PCI_READ_NO_FLUSH_MODE_BIT = 0x10000,
+	PLX9050_PCI_READ_NO_WRITE_MODE_BIT = 0x20000,
+	PLX9050_PCI_WRITE_MODE_BIT = 0x40000,
+	PLX9050_PCI_RETRY_DELAY_MASK = 0x780000,
+	PLX9050_DIRECT_SLAVE_LOCK_ENABLE_BIT = 0x800000,
+	PLX9050_EEPROM_CLOCK_BIT = 0x1000000,
+	PLX9050_EEPROM_CHIP_SELECT_BIT = 0x2000000,
+	PLX9050_WRITE_TO_EEPROM_BIT = 0x4000000,
+	PLX9050_READ_EEPROM_DATA_BIT = 0x8000000,
+	PLX9050_EEPROM_VALID_BIT = 0x10000000,
+	PLX9050_RELOAD_CONFIG_REGISTERS_BIT = 0x20000000,
+	PLX9050_PCI_SOFTWARE_RESET_BIT = 0x40000000,
+	PLX9050_MASK_REVISION_BIT = 0x80000000
+};
+static inline unsigned PLX9050_PCI_RETRY_DELAY_BITS(unsigned clocks)
+{
+	return ((clocks / 8) << 19) & PLX9050_PCI_RETRY_DELAY_MASK;
+}
+
+#endif	// _PLX9050_GPIB_H
diff --git a/drivers/gpib/include/quancom_pci.h b/drivers/gpib/include/quancom_pci.h
new file mode 100644
index 0000000..7daf29c
--- /dev/null
+++ b/drivers/gpib/include/quancom_pci.h
@@ -0,0 +1,31 @@
+/***************************************************************************
+ Quancom pci stuff
+ copyright (C) 2005 by Frank Mori Hess <fmhess@users.sourceforge.net>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ 
+#ifndef _QUANCOM_PCI_H
+#define _QUANCOM_PCI_H
+
+/* quancom registers */
+enum quancom_regs
+{
+	QUANCOM_IRQ_CONTROL_STATUS_REG = 0xfc,
+};
+
+enum quancom_irq_control_status_bits
+{
+	QUANCOM_IRQ_ASSERTED_BIT = 0x1, /* readable (any write to the register clears the interrupt)*/
+	QUANCOM_IRQ_ENABLE_BIT = 0x4, /* writeable */
+};
+
+#endif	// _QUANCOM_PCI_H
diff --git a/drivers/gpib/include/tms9914.h b/drivers/gpib/include/tms9914.h
new file mode 100644
index 0000000..0beaf59
--- /dev/null
+++ b/drivers/gpib/include/tms9914.h
@@ -0,0 +1,290 @@
+/***************************************************************************
+                                   tms9914.h
+                             -------------------
+    begin                : Feb 2002
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _TMS9914_H
+#define _TMS9914_H
+
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include "gpib_state_machines.h"
+#include "gpib_types.h"
+
+enum tms9914_holdoff_mode
+{
+	TMS9914_HOLDOFF_NONE,
+	TMS9914_HOLDOFF_EOI,
+	TMS9914_HOLDOFF_ALL,
+};
+/* struct used to provide variables local to a tms9914 chip */
+typedef struct tms9914_private_struct tms9914_private_t;
+struct tms9914_private_struct
+{
+	void *iobase;
+	unsigned int offset;	// offset between successive tms9914 io addresses
+	unsigned int dma_channel;
+	// software copy of bits written to interrupt mask registers
+	uint8_t imr0_bits, imr1_bits;
+	// bits written to address mode register
+	uint8_t admr_bits;
+	uint8_t auxa_bits;	// bits written to auxilliary register A
+	// used to keep track of board's state, bit definitions given below
+	unsigned long state;
+	uint8_t eos;	// eos character
+	short eos_flags;
+	uint8_t spoll_status;
+	enum tms9914_holdoff_mode holdoff_mode;
+	unsigned int ppoll_line;
+	enum talker_function_state talker_state;
+	enum listener_function_state listener_state;
+	unsigned ppoll_sense : 1;
+	unsigned ppoll_enable : 1;
+	unsigned ppoll_configure_state : 1;
+	unsigned primary_listen_addressed : 1;
+	unsigned primary_talk_addressed : 1;
+	unsigned holdoff_on_end : 1;
+	unsigned holdoff_on_all : 1;
+	unsigned holdoff_active : 1;
+	// wrappers for outb, inb, readb, or writeb
+	uint8_t (*read_byte)(tms9914_private_t *priv, unsigned int register_number);
+	void (*write_byte)(tms9914_private_t *priv, uint8_t byte, unsigned int
+		register_number);
+};
+
+// slightly shorter way to access read_byte and write_byte
+static inline uint8_t read_byte(tms9914_private_t *priv, unsigned int register_number)
+{
+	return priv->read_byte(priv, register_number);
+}
+static inline void write_byte(tms9914_private_t *priv, uint8_t byte, unsigned int register_number)
+{
+	priv->write_byte(priv, byte, register_number);
+}
+
+// tms9914_private_t.state bit numbers
+enum
+{
+	PIO_IN_PROGRESS_BN,	// pio transfer in progress
+	DMA_READ_IN_PROGRESS_BN,	// dma read transfer in progress
+	DMA_WRITE_IN_PROGRESS_BN,	// dma write transfer in progress
+	READ_READY_BN,	// board has data byte available to read
+	WRITE_READY_BN,	// board is ready to send a data byte
+	COMMAND_READY_BN,	// board is ready to send a command byte
+	RECEIVED_END_BN,	// received END
+	BUS_ERROR_BN,	// bus error
+	DEV_CLEAR_BN,	// device clear received
+};
+
+// interface functions
+int tms9914_read(gpib_board_t *board, tms9914_private_t *priv,
+	uint8_t *buffer, size_t length, int *end, size_t *bytes_read);
+int tms9914_write(gpib_board_t *board, tms9914_private_t *priv,
+	uint8_t *buffer, size_t length, int send_eoi, size_t *bytes_written);
+ssize_t tms9914_command(gpib_board_t *board, tms9914_private_t *priv,
+	uint8_t *buffer, size_t length);
+int tms9914_take_control(gpib_board_t *board, tms9914_private_t *priv,
+	int syncronous);
+int tms9914_go_to_standby(gpib_board_t *board, tms9914_private_t *priv);
+void tms9914_request_system_control( gpib_board_t *board, tms9914_private_t *priv,
+	int request_control );
+void tms9914_interface_clear(gpib_board_t *board, tms9914_private_t *priv, int assert);
+void tms9914_remote_enable(gpib_board_t *board, tms9914_private_t *priv, int enable);
+int tms9914_enable_eos(gpib_board_t *board, tms9914_private_t *priv,
+	uint8_t eos_bytes, int compare_8_bits);
+void tms9914_disable_eos(gpib_board_t *board, tms9914_private_t *priv);
+unsigned int tms9914_update_status( gpib_board_t *board, tms9914_private_t *priv,
+	unsigned int clear_mask );
+void tms9914_primary_address(gpib_board_t *board,
+	tms9914_private_t *priv, unsigned int address);
+void tms9914_secondary_address(gpib_board_t *board, tms9914_private_t *priv,
+	unsigned int address, int enable);
+int tms9914_parallel_poll(gpib_board_t *board, tms9914_private_t *priv, uint8_t *result);
+void tms9914_parallel_poll_configure( gpib_board_t *board,
+	tms9914_private_t *priv, uint8_t config );
+void tms9914_parallel_poll_response( gpib_board_t *board,
+	tms9914_private_t *priv, int ist );
+void tms9914_serial_poll_response(gpib_board_t *board, tms9914_private_t *priv, uint8_t status);
+uint8_t tms9914_serial_poll_status( gpib_board_t *board, tms9914_private_t *priv );
+int tms9914_line_status( const gpib_board_t *board, tms9914_private_t *priv );
+unsigned int tms9914_t1_delay( gpib_board_t *board, tms9914_private_t *priv,
+	unsigned int nano_sec );
+void tms9914_return_to_local( const gpib_board_t *board, tms9914_private_t *priv );
+
+// utility functions
+void tms9914_board_reset(tms9914_private_t *priv);
+void tms9914_online( gpib_board_t *board, tms9914_private_t *priv );
+void tms9914_release_holdoff(tms9914_private_t *priv);
+void tms9914_set_holdoff_mode(tms9914_private_t *priv, enum tms9914_holdoff_mode mode);
+
+// wrappers for io functions
+uint8_t tms9914_ioport_read_byte(tms9914_private_t *priv, unsigned int register_num);
+void tms9914_ioport_write_byte(tms9914_private_t *priv, uint8_t data, unsigned int register_num);
+uint8_t tms9914_iomem_read_byte(tms9914_private_t *priv, unsigned int register_num);
+void tms9914_iomem_write_byte(tms9914_private_t *priv, uint8_t data, unsigned int register_num);
+
+// interrupt service routine
+irqreturn_t tms9914_interrupt(gpib_board_t *board, tms9914_private_t *priv );
+irqreturn_t tms9914_interrupt_have_status(gpib_board_t *board, tms9914_private_t *priv, int status1,
+		int status2);
+
+// tms9914 has 8 registers
+static const int tms9914_num_registers = 8;
+
+/* tms9914 register numbers (might need to be multiplied by
+ * a board-dependent offset to get actually io address offset)
+ */
+// write registers
+enum
+{
+	IMR0 = 0,	/* interrupt mask 0          */
+	IMR1 = 1,	/* interrupt mask 1          */
+	AUXCR = 3,	/* auxiliary command         */
+	ADR = 4,	// address register
+	SPMR = 5,	// serial poll mode register
+	PPR = 6,	/* parallel poll             */
+	CDOR = 7,	/* data out register         */
+};
+// read registers
+enum
+{
+	ISR0 = 0,	/* interrupt status 0          */
+	ISR1 = 1,	/* interrupt status 1          */
+	ADSR = 2,	/* address status               */
+	BSR = 3,	/* bus status */
+	CPTR = 6,	/* command pass thru           */
+	DIR = 7,	/* data in register            */
+};
+
+//bit definitions common to tms9914 compatible registers
+
+/* ISR0   - Register bits */
+enum isr0_bits
+{
+	HR_MAC = ( 1 << 0 ),   /* My Address Change           */
+	HR_RLC = ( 1 << 1 ),   /* Remote/Local change         */
+	HR_SPAS = ( 1 << 2 ),   /* Serial Poll active State    */
+	HR_END = ( 1 << 3 ),   /* END (EOI or EOS)            */
+	HR_BO = ( 1 << 4 ),   /* Byte Out                    */
+	HR_BI = ( 1 << 5 ),   /* Byte In                     */
+};
+
+/* IMR0   - Register bits */
+enum imr0_bits
+{
+	HR_MACIE = ( 1 << 0 ),   /*        */
+	HR_RLCIE = ( 1 << 1 ),   /*        */
+	HR_SPASIE = ( 1 << 2 ),   /*        */
+	HR_ENDIE = ( 1 << 3 ),   /*        */
+	HR_BOIE = ( 1 << 4 ),   /*        */
+	HR_BIIE = ( 1 << 5 ),   /*        */
+};
+
+/* ISR1   - Register bits */
+enum isr1_bits
+{
+	HR_IFC = ( 1 << 0 ),   /* IFC asserted                */
+	HR_SRQ = ( 1 << 1 ),   /* SRQ asserted                */
+	HR_MA = ( 1 << 2 ),   /* My Adress                   */
+	HR_DCAS = ( 1 << 3 ),   /* Device Clear active State   */
+	HR_APT = ( 1 << 4 ),   /* Adress pass Through         */
+	HR_UNC = ( 1 << 5 ),   /* Unrecognized Command        */
+	HR_ERR = ( 1 << 6 ),   /* Data Transmission Error     */
+	HR_GET = ( 1 << 7 ),   /* Group execute Trigger       */
+};
+
+/* IMR1   - Register bits */
+enum imr1_bits
+{
+	HR_IFCIE = ( 1 << 0 ),   /*        */
+	HR_SRQIE = ( 1 << 1 ),   /*        */
+	HR_MAIE = ( 1 << 2 ),   /*        */
+	HR_DCASIE = ( 1 << 3 ),   /*        */
+	HR_APTIE = ( 1 << 4 ),   /*        */
+	HR_UNCIE = ( 1 << 5 ),   /*        */
+	HR_ERRIE = ( 1 << 6 ),   /*        */
+	HR_GETIE = ( 1 << 7 ),   /*        */
+};
+
+/* ADSR   - Register bits */
+enum adsr_bits
+{
+	HR_ULPA = ( 1 << 0 ),   /* Store last address LSB      */
+	HR_TA = ( 1 << 1 ),   /* Talker Adressed             */
+	HR_LA = ( 1 << 2 ),   /* Listener adressed           */
+	HR_TPAS = ( 1 << 3 ),   /* talker primary adress state */
+	HR_LPAS = ( 1 << 4 ),   /* listener    "               */
+	HR_ATN = ( 1 << 5 ),   /* ATN active                  */
+	HR_LLO = ( 1 << 6 ),   /* LLO active                  */
+	HR_REM = ( 1 << 7 ),   /* REM active                  */
+};
+
+/* ADR   - Register bits */
+enum adr_bits
+{
+	ADDRESS_MASK = 0x1f,	/* mask to specify lower 5 bits for ADR */
+	HR_DAT = ( 1 << 5 ),   /* disable talker */
+	HR_DAL = ( 1 << 6 ),   /* disable listener */
+	HR_EDPA = ( 1 << 7 ),   /* enable dual primary addressing */
+};
+
+enum bus_status_bits
+{
+	BSR_REN_BIT = 0x1,
+	BSR_IFC_BIT = 0x2,
+	BSR_SRQ_BIT = 0x4,
+	BSR_EOI_BIT = 0x8,
+	BSR_NRFD_BIT = 0x10,
+	BSR_NDAC_BIT = 0x20,
+	BSR_DAV_BIT = 0x40,
+	BSR_ATN_BIT = 0x80,
+};
+
+/*---------------------------------------------------------*/
+/* TMS 9914 Auxiliary Commands                             */
+/*---------------------------------------------------------*/
+
+enum aux_cmd_bits
+{
+	AUX_CS = 0x80,	/* set bit instead of clearing it, used with commands marked 'd' below */
+	AUX_CHIP_RESET = 0x0,	/* d Chip reset                   */
+	AUX_INVAL = 0x1,	// release dac holdoff, invalid command byte
+	AUX_VAL = ( AUX_INVAL | AUX_CS ),	// release dac holdoff, valid command byte
+	AUX_RHDF = 0x2,	/* X Release RFD holdoff          */
+	AUX_HLDA = 0x3,	/* d holdoff on all data          */
+	AUX_HLDE = 0x4,	/* d holdoff on EOI only          */
+	AUX_NBAF = 0x5,	/* X Set new byte availiable false */
+	AUX_FGET = 0x6,	/* d force GET                    */
+	AUX_RTL = 0x7,	/* d return to local              */
+	AUX_SEOI = 0x8,	/* X send EOI with next byte      */
+	AUX_LON = 0x9,	/* d Listen only                  */
+	AUX_TON = 0xa,	/* d Talk only                    */
+	AUX_GTS = 0xb,	/* X goto standby                 */
+	AUX_TCA = 0xc,	/* X take control asynchronously  */
+	AUX_TCS = 0xd,	/* X take    "     synchronously  */
+	AUX_RPP = 0xe,	/* d Request parallel poll        */
+	AUX_SIC = 0xf,	/* d send interface clear         */
+	AUX_SRE = 0x10,	/* d send remote enable           */
+	AUX_RQC = 0x11,	/* X request control              */
+	AUX_RLC = 0x12,	/* X release control              */
+	AUX_DAI = 0x13,	/* d disable all interrupts       */
+	AUX_PTS = 0x14,	/* X pass through next secondary  */
+	AUX_STDL = 0x15,	/* d short T1 delay                 */
+	AUX_SHDW = 0x16,	/* d shadow handshake             */
+	AUX_VSTDL = 0x17,	/* d very short T1 delay (smj9914 extension) */
+	AUX_RSV2 = 0x18,	/* d request service bit 2 (smj9914 extension) */
+};
+
+#endif	//_TMS9914_H
diff --git a/drivers/gpib/include/tnt4882_registers.h b/drivers/gpib/include/tnt4882_registers.h
new file mode 100644
index 0000000..979c113
--- /dev/null
+++ b/drivers/gpib/include/tnt4882_registers.h
@@ -0,0 +1,211 @@
+/***************************************************************************
+                              tnt4882_registers.h
+                             -------------------
+
+    begin                : Jan 2002
+    copyright            : (C) 2002, 2004 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _TNT4882_REGISTERS_H
+#define _TNT4882_REGISTERS_H
+
+// tnt4882 register offsets
+enum
+{
+	ACCWR = 0x5,
+	// offset of auxilliary command register in 9914 mode
+	AUXCR = 0x6,
+	INTRT = 0x7,
+	// register number for auxilliary command register when swap bit is set (9914 mode)
+	SWAPPED_AUXCR = 0xa,
+	HSSEL = 0xd,	// handshake select register
+	CNT2 = 0x9,
+	CNT3 = 0xb,
+	CFG = 0x10,
+	SASR = 0x1b,
+	IMR0 = 0x1d,
+	IMR3 = 0x12,
+	CNT0 = 0x14,
+	CNT1 = 0x16,
+	KEYREG = 0x17,	// key control register (7210 mode only)
+	CSR = KEYREG,
+	FIFOB = 0x18,
+	FIFOA = 0x19,
+	CCR = 0x1a,	// carry cycle register
+	CMDR = 0x1c,	// command register
+	TIMER = 0x1e,	// timer register
+
+	STS1 = 0x10,		/* T488 Status Register 1 */
+	STS2 = 0x1c,	        /* T488 Status Register 2 */
+	ISR0 = IMR0,
+	ISR3 = 0x1a,		/* T488 Interrupt Status Register 3 */
+	BCR = 0x1f,		/* bus control/status register */
+	BSR = BCR,
+};
+static const int tnt_pagein_offset = 0x11;
+
+/*============================================================*/
+
+/* TURBO-488 registers bit definitions */
+
+enum bus_control_status_bits
+{
+	BCSR_REN_BIT = 0x1,
+	BCSR_IFC_BIT = 0x2,
+	BCSR_SRQ_BIT = 0x4,
+	BCSR_EOI_BIT = 0x8,
+	BCSR_NRFD_BIT = 0x10,
+	BCSR_NDAC_BIT = 0x20,
+	BCSR_DAV_BIT = 0x40,
+	BCSR_ATN_BIT = 0x80,
+};
+
+/* CFG -- Configuration Register (write only) */
+enum cfg_bits
+{
+	TNT_COMMAND = 0x80,	/* bytes are command bytes instead of data bytes (tnt4882 one-chip and newer only?)*/
+	TNT_TLCHE = ( 1 << 6 ),	/* halt transfer on imr0, imr1, or imr2 interrupt */
+	TNT_IN = ( 1 << 5 ),	/* transfer is GPIB read                 */
+	TNT_A_B = ( 1 << 4 ),	/* order to use fifos 1=fifa A first(big endian), 0=fifo b first(little endian) */
+	TNT_CCEN = ( 1 << 3 ),	/* enable carry cycle                 */
+	TNT_TMOE = ( 1 << 2 ),	/* enable CPU bus time limit          */
+	TNT_TIM_BYTN = ( 1 << 1 ),	/* tmot reg is: 1=125ns clocks, 0=num bytes */
+	TNT_B_16BIT = ( 1 << 0 ),	/* 1=FIFO is 16-bit register, 0=8-bit */
+};
+
+/* CMDR -- Command Register */
+enum cmdr_bits
+{
+	CLRSC = 0x2,	/* clear the system controller bit */
+	SETSC = 0x3,	/* set the system controller bit */
+	GO = 0x4,	/* start fifos */
+	STOP = 0x8,	/* stop fifos */
+	RESET_FIFO = 0x10,	/* reset the FIFOs 		*/
+	SOFT_RESET = 0x22,	/* issue a software reset 	*/
+	HARD_RESET = 0x40	/* 500x only? */
+};
+
+/* HSSEL -- handshake select register (write only) */
+enum hssel_bits
+{
+	TNT_ONE_CHIP_BIT = 0x1,
+	NODMA = 0x10,
+	TNT_GO2SIDS_BIT = 0x20,
+};
+
+/* IMR0 -- Interrupt Mode Register 0 */
+enum imr0_bits
+{
+	TNT_SYNCIE_BIT = 0x1, /* handshake sync */
+	TNT_TOIE_BIT = 0x2, /* timeout */
+	TNT_ATNIE_BIT = 0x4, /* ATN interrupt */
+	TNT_IFCIE_BIT = 0x8,	/* interface clear interrupt */
+	TNT_BTO_BIT = 0x10, /* byte timeout */
+	TNT_NLEN_BIT = 0x20,	/* treat new line as EOS char */
+	TNT_STBOIE_BIT = 0x40,	/* status byte out  */
+	TNT_IMR0_ALWAYS_BITS = 0x80,	/* always set this bit on write */
+};
+
+/* ISR0 -- Interrupt Status Register 0 */
+enum isr0_bits
+{
+	TNT_SYNC_BIT = 0x1, /* handshake sync */
+	TNT_TO_BIT = 0x2, /* timeout */
+	TNT_ATNI_BIT = 0x4, /* ATN interrupt */
+	TNT_IFCI_BIT = 0x8,	/* interface clear interrupt */
+	TNT_EOS_BIT = 0x10, /* end of string */
+	TNT_NL_BIT = 0x20,	/* new line receive */
+	TNT_STBO_BIT = 0x40,	/* status byte out  */
+	TNT_NBA_BIT = 0x80,	/* new byte available */
+};
+
+/* ISR3 -- Interrupt Status Register 3 (read only) */
+enum isr3_bits
+{
+	HR_DONE = ( 1 << 0 ),	/* transfer done */
+	HR_TLCI = ( 1 << 1 ),	/* isr0, isr1, or isr2 interrupt asserted */
+	HR_NEF = ( 1 << 2 ),	/* NOT empty fifo */
+	HR_NFF = ( 1 << 3 ),	/* NOT full fifo */
+	HR_STOP = ( 1 << 4 ),	/* fifo empty or STOP command issued */
+	HR_SRQI_CIC = ( 1 << 5 ),	/* SRQ asserted and we are CIC (500x only?)*/
+	HR_INTR = ( 1 << 7 ),	/* isr3 interrupt active */
+};
+
+enum keyreg_bits
+{
+	MSTD = 0x20,	// enable 350ns T1 delay
+};
+
+/* STS1 -- Status Register 1 (read only) */
+enum sts1_bits
+{
+	S_DONE = 0x80,	/* DMA done                           */
+	S_SC = 0x40,	/* is system contoller                */
+	S_IN = 0x20,	/* DMA in (to memory)                 */
+	S_DRQ = 0x10,	/* DRQ line (for diagnostics)         */
+	S_STOP = 0x08,	/* DMA stopped                        */
+	S_NDAV = 0x04,	/* inverse of DAV                     */
+	S_HALT = 0x02,	/* status of transfer machine         */
+	S_GSYNC = 0x01,	/* indicates if GPIB is in sync w I/O */
+};
+
+/* STS2 -- Status Register 2 */
+enum sts2_bits
+{
+	AFFN = ( 1 << 3 ), 	/* "A full FIFO NOT"  (0=FIFO full)  */
+	AEFN = ( 1 << 2 ),	/* "A empty FIFO NOT" (0=FIFO empty) */
+	BFFN = ( 1 << 1 ),	/* "B full FIFO NOT"  (0=FIFO full)  */
+	BEFN = ( 1 << 0 ),	/* "B empty FIFO NOT" (0=FIFO empty) */
+};
+
+// Auxilliary commands
+enum tnt4882_aux_cmds
+{
+	AUX_9914 = 0x15,	// switch to 9914 mode
+	AUX_PAGEIN = 0x50,	/* page in alternate registers */
+	AUX_HLDI = 0x51,	// rfd holdoff immediately
+	AUX_CLEAR_END = 0x55,
+	AUX_7210 = 0x99,	// switch to 7210 mode
+};
+
+enum tnt4882_aux_regs
+{
+	AUXRG = 0x40,
+	AUXRI = 0xe0,
+};
+
+enum auxg_bits
+{
+ /* no talking when no listeners bit (prevents bus errors when data written at wrong time) */
+	NTNL_BIT = 0x8,
+	RPP2_BIT = 0x4,	/* set/clear local rpp message */
+	CHES_BIT = 0x1, /*clear holdoff on end select bit*/
+};
+
+enum auxi_bits
+{
+	SISB = 0x1,	// static interrupt bits (don't clear isr1, isr2 on read )
+	PP2 = 0x4,	// ignore remote parallel poll configuration
+	USTD = 0x8,	// ultra short ( 1100 nanosec ) T1 delay
+};
+
+enum sasr_bits
+{
+	ACRDY_BIT = 0x4,	/* acceptor ready state */
+	ADHS_BIT = 0x8,	/* acceptor data holdoff state */
+	ANHS2_BIT = 0x10,	/* acceptor not ready holdoff immediately state */
+	ANHS1_BIT = 0x20,	/* acceptor not ready holdoff state */
+	AEHS_BIT = 0x40,	/* acceptor end holdoff state */
+};
+
+#endif	// _TNT4882_REGISTERS_H
diff --git a/drivers/gpib/nec7210/Makefile b/drivers/gpib/nec7210/Makefile
new file mode 100644
index 0000000..b31e4f6
--- /dev/null
+++ b/drivers/gpib/nec7210/Makefile
@@ -0,0 +1,8 @@
+
+EXTRA_CFLAGS += -Idrivers/gpib/include
+
+obj-$(CONFIG_FLUKE_GPIB) += nec7210.o
+
+nec7210-objs := cmd.o init.o read.o util.o write.o nec7210_aux.o interrupt.o
+
+
diff --git a/drivers/gpib/nec7210/board.h b/drivers/gpib/nec7210/board.h
new file mode 100644
index 0000000..dfda673
--- /dev/null
+++ b/drivers/gpib/nec7210/board.h
@@ -0,0 +1,34 @@
+/***************************************************************************
+                              nec7210/board.h
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef _GPIB_PCIIA_BOARD_H
+#define _GPIB_PCIIA_BOARD_H
+
+#include "gpibP.h"
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+
+#include "nec7210.h"
+
+unsigned int update_status_nolock( gpib_board_t *board, nec7210_private_t *priv );
+
+#endif	//_GPIB_PCIIA_BOARD_H
+
diff --git a/drivers/gpib/nec7210/cmd.c b/drivers/gpib/nec7210/cmd.c
new file mode 100644
index 0000000..cbe5953
--- /dev/null
+++ b/drivers/gpib/nec7210/cmd.c
@@ -0,0 +1,87 @@
+/***************************************************************************
+                                    nec7210/cmd.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "board.h"
+
+ssize_t nec7210_command(gpib_board_t *board, nec7210_private_t *priv, uint8_t
+ *buffer, size_t length)
+{
+	size_t count = 0;
+	ssize_t retval = 0;
+	unsigned long flags;
+
+	clear_bit( BUS_ERROR_BN, &priv->state );
+	while(count < length)
+	{
+		if(wait_event_interruptible(board->wait, test_bit(COMMAND_READY_BN, &priv->state) ||
+			test_bit( BUS_ERROR_BN, &priv->state ) || test_bit(TIMO_NUM, &board->status)))
+		{
+			printk("gpib command wait interrupted\n");
+			retval = -ERESTARTSYS;
+			break;
+		}
+		if(test_bit(TIMO_NUM, &board->status))
+		{
+			break;
+		}
+		if(test_and_clear_bit( BUS_ERROR_BN, &priv->state))
+		{
+			printk("nec7210: bus error on command byte\n");
+			break;
+		}
+
+		spin_lock_irqsave( &board->spinlock, flags );
+		clear_bit( COMMAND_READY_BN, &priv->state );
+		write_byte( priv, buffer[count], CDOR );
+		spin_unlock_irqrestore( &board->spinlock, flags );
+
+		count++;
+
+		if(need_resched())
+			schedule();
+	}
+	// wait for last byte to get sent
+	if(wait_event_interruptible(board->wait, test_bit(COMMAND_READY_BN, &priv->state) ||
+		test_bit( BUS_ERROR_BN, &priv->state ) || test_bit(TIMO_NUM, &board->status)))
+	{
+		printk("gpib command wait interrupted\n");
+		retval = -ERESTARTSYS;
+	}
+	if(test_bit(TIMO_NUM, &board->status))
+	{
+		printk("gpib command timed out\n");
+		retval = -ETIMEDOUT;
+	}
+	if(test_and_clear_bit( BUS_ERROR_BN, &priv->state))
+	{
+		printk("nec7210: bus error on command byte\n");
+		retval = -EIO;
+	}
+
+	return retval ? retval : count;
+}
+
+EXPORT_SYMBOL(nec7210_command);
+
+
+
+
+
+
+
+
diff --git a/drivers/gpib/nec7210/init.c b/drivers/gpib/nec7210/init.c
new file mode 100644
index 0000000..68888e9
--- /dev/null
+++ b/drivers/gpib/nec7210/init.c
@@ -0,0 +1,176 @@
+/***************************************************************************
+                          nec7210/init.c  -  description
+                             -------------------
+ board specific initialization stuff
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "board.h"
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/dma.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/string.h>
+#include <linux/init.h>
+
+MODULE_LICENSE("GPL");
+
+void nec7210_board_reset( nec7210_private_t *priv, const gpib_board_t *board )
+{
+	/* 7210 chip reset */
+	write_byte(priv, AUX_CR, AUXMR);
+
+	/* disable all interrupts */
+	priv->reg_bits[ IMR1 ] = 0;
+	write_byte(priv, priv->reg_bits[ IMR1 ], IMR1);
+	priv->reg_bits[ IMR2 ] = 0;
+	write_byte(priv, priv->reg_bits[ IMR2 ], IMR2);
+	write_byte(priv, 0, SPMR);
+
+	/* clear registers by reading */
+	read_byte(priv, CPTR);
+	read_byte(priv, ISR1);
+	read_byte(priv, ISR2);
+
+	/* parallel poll unconfigure */
+	write_byte(priv, PPR | HR_PPU, AUXMR);
+
+	priv->reg_bits[ ADMR ] = HR_TRM0 | HR_TRM1;
+
+	priv->auxa_bits = AUXRA | HR_HLDA;
+	write_byte(priv, priv->auxa_bits, AUXMR);
+
+	write_byte( priv, AUXRE | 0, AUXMR );
+
+	/* set INT pin to active high, enable command pass through of unknown commands */
+	priv->auxb_bits = AUXRB | HR_CPTE;
+	write_byte(priv, priv->auxb_bits, AUXMR);
+	write_byte(priv, AUXRE, AUXMR);
+}
+
+void nec7210_board_online( nec7210_private_t *priv, const gpib_board_t *board )
+{
+	/* set GPIB address */
+	nec7210_primary_address( board, priv, board->pad );
+	nec7210_secondary_address( board, priv, board->sad, board->sad >= 0 );
+
+	// enable interrupts
+	priv->reg_bits[ IMR1 ] = HR_ERRIE | HR_DECIE | HR_ENDIE |
+		HR_DETIE | HR_CPTIE | HR_DOIE | HR_DIIE;
+	priv->reg_bits[ IMR2 ] = IMR2_ENABLE_INTR_MASK;
+	write_byte( priv, priv->reg_bits[ IMR1 ], IMR1);
+	write_byte( priv, priv->reg_bits[ IMR2 ], IMR2);
+
+	write_byte( priv, AUX_PON, AUXMR);
+}
+
+/* wrappers for io */
+uint8_t nec7210_ioport_read_byte(nec7210_private_t *priv, unsigned int register_num)
+{
+	return inb((unsigned long)(priv->iobase) + register_num * priv->offset);
+}
+void nec7210_ioport_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num)
+{
+	if(register_num == AUXMR)
+	{
+		/* locking makes absolutely sure noone accesses the
+		 * AUXMR register faster than once per microsecond */
+		nec7210_locking_ioport_write_byte( priv, data, register_num );
+	}else
+		outb(data, (unsigned long)(priv->iobase) + register_num * priv->offset);
+}
+uint8_t nec7210_iomem_read_byte(nec7210_private_t *priv, unsigned int register_num)
+{
+	return readb(priv->iobase + register_num * priv->offset);
+}
+void nec7210_iomem_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num)
+{
+	if(register_num == AUXMR)
+	{
+		/* locking makes absolutely sure noone accesses the
+		 * AUXMR register faster than once per microsecond */
+		nec7210_locking_iomem_write_byte( priv, data, register_num );
+	}else
+		writeb(data, priv->iobase + register_num * priv->offset);
+}
+/* locking variants of io wrappers, for chips that page-in registers */
+uint8_t nec7210_locking_ioport_read_byte(nec7210_private_t *priv, unsigned int register_num)
+{
+	uint8_t retval;
+	unsigned long flags;
+
+	spin_lock_irqsave( &priv->register_page_lock, flags );
+	retval = inb((unsigned long)(priv->iobase) + register_num * priv->offset);
+	spin_unlock_irqrestore( &priv->register_page_lock, flags );
+	return retval;
+}
+void nec7210_locking_ioport_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave( &priv->register_page_lock, flags );
+	if(register_num == AUXMR)
+		udelay(1);
+	outb(data, (unsigned long)(priv->iobase) + register_num * priv->offset);
+	spin_unlock_irqrestore( &priv->register_page_lock, flags );
+}
+uint8_t nec7210_locking_iomem_read_byte(nec7210_private_t *priv, unsigned int register_num)
+{
+	uint8_t retval;
+	unsigned long flags;
+
+	spin_lock_irqsave( &priv->register_page_lock, flags );
+	retval = readb(priv->iobase + register_num * priv->offset);
+	spin_unlock_irqrestore( &priv->register_page_lock, flags );
+	return retval;
+}
+void nec7210_locking_iomem_write_byte(nec7210_private_t *priv, uint8_t data, unsigned int register_num)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave( &priv->register_page_lock, flags );
+	if(register_num == AUXMR)
+		udelay(1);
+	writeb(data, priv->iobase + register_num * priv->offset);
+	spin_unlock_irqrestore( &priv->register_page_lock, flags );
+}
+
+static int __init nec7210_init_module( void )
+{
+	return 0;
+}
+
+static void __exit nec7210_exit_module( void )
+{
+}
+
+module_init( nec7210_init_module );
+module_exit( nec7210_exit_module );
+
+EXPORT_SYMBOL(nec7210_board_reset);
+EXPORT_SYMBOL(nec7210_board_online);
+
+EXPORT_SYMBOL(nec7210_ioport_read_byte);
+EXPORT_SYMBOL(nec7210_ioport_write_byte);
+EXPORT_SYMBOL(nec7210_iomem_read_byte);
+EXPORT_SYMBOL(nec7210_iomem_write_byte);
+EXPORT_SYMBOL(nec7210_locking_ioport_read_byte);
+EXPORT_SYMBOL(nec7210_locking_ioport_write_byte);
+EXPORT_SYMBOL(nec7210_locking_iomem_read_byte);
+EXPORT_SYMBOL(nec7210_locking_iomem_write_byte);
+
diff --git a/drivers/gpib/nec7210/interrupt.c b/drivers/gpib/nec7210/interrupt.c
new file mode 100644
index 0000000..8534567
--- /dev/null
+++ b/drivers/gpib/nec7210/interrupt.c
@@ -0,0 +1,196 @@
+/***************************************************************************
+                              nec7210/interrupt.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "board.h"
+#include <asm/bitops.h>
+#include <asm/dma.h>
+
+static inline short nec7210_atn_has_changed(gpib_board_t *board, nec7210_private_t *priv)
+{
+	short address_status_bits = read_byte(priv, ADSR);
+
+	if(address_status_bits & HR_NATN)
+	{
+		if(test_bit(ATN_NUM, &board->status))
+			return 1;
+		else return 0;
+	}else
+	{
+		if(test_bit(ATN_NUM, &board->status))
+			return 0;
+		else return 1;
+	}
+	return -1;
+}
+/*
+ *  interrupt service routine
+ */
+irqreturn_t nec7210_interrupt( gpib_board_t *board, nec7210_private_t *priv )
+{
+	int status1, status2;
+
+	// read interrupt status (also clears status)
+	status1 = read_byte(priv, ISR1);
+	status2 = read_byte(priv, ISR2);
+
+	return nec7210_interrupt_have_status( board, priv, status1, status2 );
+}
+
+irqreturn_t nec7210_interrupt_have_status( gpib_board_t *board,
+	nec7210_private_t *priv, int status1, int status2 )
+{
+#if 0
+	unsigned long dma_flags;
+#endif
+	int retval = IRQ_NONE;
+	
+	// record service request in status
+	if(status2 & HR_SRQI)
+	{
+		set_bit(SRQI_NUM, &board->status);
+	}
+
+	// change in lockout status
+	if(status2 & HR_LOKC)
+	{
+		if(status2 & HR_LOK)
+			set_bit(LOK_NUM, &board->status);
+		else
+			clear_bit(LOK_NUM, &board->status);
+	}
+
+	// change in remote status
+	if(status2 & HR_REMC)
+	{
+		if(status2 & HR_REM)
+			set_bit(REM_NUM, &board->status);
+		else
+			clear_bit(REM_NUM, &board->status);
+	}
+
+	// record reception of END
+	if(status1 & HR_END)
+	{
+		set_bit(RECEIVED_END_BN, &priv->state);
+		if( ( priv->auxa_bits & HR_HANDSHAKE_MASK ) == HR_HLDE )
+			set_bit( RFD_HOLDOFF_BN, &priv->state);
+	}
+
+	// get incoming data in PIO mode
+	if((status1 & HR_DI))
+	{
+		set_bit(READ_READY_BN, &priv->state);
+		if( ( priv->auxa_bits & HR_HANDSHAKE_MASK ) == HR_HLDA )
+			set_bit( RFD_HOLDOFF_BN, &priv->state);
+	}
+#if 0
+	// check for dma read transfer complete
+	if(test_bit(DMA_READ_IN_PROGRESS_BN, &priv->state))
+	{
+		dma_flags = claim_dma_lock();
+		disable_dma(priv->dma_channel);
+		clear_dma_ff(priv->dma_channel);
+		if((status1 & HR_END) || get_dma_residue(priv->dma_channel) == 0)
+		{
+			clear_bit(DMA_READ_IN_PROGRESS_BN, &priv->state);
+		}else
+			enable_dma(priv->dma_channel);
+		release_dma_lock( dma_flags );
+	}
+#endif
+	if((status1 & HR_DO))
+	{
+		if(test_bit(DMA_WRITE_IN_PROGRESS_BN, &priv->state) == 0)
+			set_bit(WRITE_READY_BN, &priv->state);
+#if 0
+		if(test_bit(DMA_WRITE_IN_PROGRESS_BN, &priv->state))	// write data, isa dma mode
+		{
+			// check if dma transfer is complete
+			dma_flags = claim_dma_lock();
+			disable_dma(priv->dma_channel);
+			clear_dma_ff(priv->dma_channel);
+			if(get_dma_residue(priv->dma_channel) == 0)
+			{
+				clear_bit(DMA_WRITE_IN_PROGRESS_BN, &priv->state);
+				// XXX race? byte may still be in CDOR reg
+			}else
+			{
+				clear_bit(WRITE_READY_BN, &priv->state);
+				enable_dma(priv->dma_channel);
+			}
+			release_dma_lock( dma_flags );
+		}
+#endif
+	}
+
+	// outgoing command can be sent
+	if(status2 & HR_CO)
+	{
+		set_bit(COMMAND_READY_BN, &priv->state);
+	}
+
+	// command pass through received
+	if(status1 & HR_CPT)
+	{
+		unsigned int command;
+
+		command = read_byte(priv, CPTR);
+		write_byte(priv, AUX_NVAL, AUXMR);
+		printk( "gpib: command pass through 0x%x\n", command );
+	}
+
+	if(status1 & HR_ERR)
+	{
+		set_bit( BUS_ERROR_BN, &priv->state );
+		printk("nec7210: bus error\n");
+	}
+
+	if( status1 & HR_DEC )
+	{
+		unsigned short address_status_bits = read_byte(priv, ADSR);
+
+		// ignore device clear events if we are controller in charge
+		if((address_status_bits & HR_CIC) == 0)
+		{
+			push_gpib_event( board, EventDevClr );
+			set_bit( DEV_CLEAR_BN, &priv->state );
+		}
+	}
+
+	if( status1 & HR_DET )
+	{
+		push_gpib_event( board, EventDevTrg );
+	}
+
+	if((status1 & priv->reg_bits[ IMR1 ]) ||
+		(status2 & (priv->reg_bits[ IMR2 ] & IMR2_ENABLE_INTR_MASK)) ||
+		nec7210_atn_has_changed(board, priv))
+	{
+		GPIB_DPRINTK( "minor %i, isr1 0x%x, imr1 0x%x, isr2 0x%x, imr2 0x%x\n",
+			board->minor, status1, priv->reg_bits[ IMR1 ], status2, priv->reg_bits[ IMR2 ] );
+		update_status_nolock(board, priv);
+		wake_up_interruptible(&board->wait); /* wake up sleeping process */
+		retval = IRQ_HANDLED;
+	}
+	return retval;
+}
+
+EXPORT_SYMBOL(nec7210_interrupt);
+EXPORT_SYMBOL(nec7210_interrupt_have_status);
+
+
diff --git a/drivers/gpib/nec7210/nec7210_aux.c b/drivers/gpib/nec7210/nec7210_aux.c
new file mode 100644
index 0000000..1b0ea54
--- /dev/null
+++ b/drivers/gpib/nec7210/nec7210_aux.c
@@ -0,0 +1,174 @@
+/***************************************************************************
+                                 nec7210/aux.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "board.h"
+#include <asm/bitops.h>
+
+int nec7210_take_control(gpib_board_t *board, nec7210_private_t *priv, int syncronous)
+{
+	int i;
+	const int timeout = 1000;
+	int retval = 0;
+	unsigned int adsr_bits = 0;
+
+	if(syncronous)
+	{
+		write_byte(priv, AUX_TCS, AUXMR);
+	}else
+		write_byte(priv, AUX_TCA, AUXMR);
+	// busy wait until ATN is asserted
+	for(i = 0; i < timeout; i++)
+	{
+		adsr_bits = read_byte(priv, ADSR);
+		if((adsr_bits & HR_NATN) == 0)
+			break;
+		udelay(1);
+	}
+	// if busy wait has failed, try sleeping
+	if( i == timeout )
+	{
+		for(i = 0; i < HZ; i++)
+		{
+			set_current_state(TASK_INTERRUPTIBLE);
+			if(schedule_timeout(1))
+				return -ERESTARTSYS;
+			adsr_bits = read_byte(priv, ADSR);
+			if((adsr_bits & HR_NATN) == 0)
+				break;
+		}
+		if(i == HZ)
+		{
+			printk("nec7210: error waiting for ATN\n");
+			return -ETIMEDOUT;
+		}
+	}
+	clear_bit( WRITE_READY_BN, &priv->state );
+	return retval;
+}
+
+int nec7210_go_to_standby(gpib_board_t *board, nec7210_private_t *priv)
+{
+	int i;
+	const int timeout = 1000;
+	unsigned int adsr_bits = 0;
+	int retval = 0;
+
+	write_byte(priv, AUX_GTS, AUXMR);
+	// busy wait until ATN is released
+	for(i = 0; i < timeout; i++)
+	{
+		adsr_bits = read_byte(priv, ADSR);
+		if(adsr_bits & HR_NATN)
+			break;
+		udelay(1);
+	}
+	// if busy wait has failed, try sleeping
+	if(i == timeout)
+	{
+		for(i = 0; i < HZ; i++)
+		{
+			set_current_state(TASK_INTERRUPTIBLE);
+			if(schedule_timeout(1))
+				return -ERESTARTSYS;
+			adsr_bits = read_byte(priv, ADSR);
+			if(adsr_bits & HR_NATN)
+				break;
+		}
+		if(i == HZ)
+		{
+			printk("nec7210: error waiting for NATN\n");
+			return -ETIMEDOUT;
+		}
+	}
+	clear_bit( COMMAND_READY_BN, &priv->state );
+	return retval;
+}
+
+void nec7210_request_system_control( gpib_board_t *board, nec7210_private_t *priv,
+	int request_control )
+{
+	if( request_control == 0 )
+	{
+		write_byte( priv, AUX_CREN, AUXMR );
+		write_byte( priv, AUX_CIFC, AUXMR );
+		write_byte( priv, AUX_DSC, AUXMR );
+	}
+}
+
+void nec7210_interface_clear(gpib_board_t *board, nec7210_private_t *priv, int assert)
+{
+	if(assert)
+		write_byte(priv, AUX_SIFC, AUXMR);
+	else
+		write_byte(priv, AUX_CIFC, AUXMR);
+}
+
+void nec7210_remote_enable(gpib_board_t *board, nec7210_private_t *priv, int enable)
+{
+	if(enable)
+		write_byte(priv, AUX_SREN, AUXMR);
+	else
+		write_byte(priv, AUX_CREN, AUXMR);
+}
+
+void nec7210_release_rfd_holdoff( gpib_board_t *board, nec7210_private_t *priv )
+{
+	unsigned long flags;
+
+	spin_lock_irqsave( &board->spinlock, flags );
+	if( test_bit( RFD_HOLDOFF_BN, &priv->state ) &&
+		test_bit( READ_READY_BN, &priv->state ) == 0 )
+	{
+		write_byte( priv, AUX_FH, AUXMR );
+		clear_bit( RFD_HOLDOFF_BN, &priv->state );
+	}
+	spin_unlock_irqrestore( &board->spinlock, flags );
+}
+
+unsigned int nec7210_t1_delay( gpib_board_t *board, nec7210_private_t *priv,
+	unsigned int nano_sec )
+{
+	unsigned int retval;
+
+	if( nano_sec <= 500 )
+	{
+		priv->auxb_bits |= HR_TRI;
+		retval = 500;
+	}else
+	{
+		priv->auxb_bits &= ~HR_TRI;
+		retval = 2000;
+	}
+	write_byte( priv, priv->auxb_bits, AUXMR );
+
+	return retval;
+}
+
+void nec7210_return_to_local( const gpib_board_t *board, nec7210_private_t *priv )
+{
+	write_byte( priv, AUX_RTL, AUXMR );
+}
+
+EXPORT_SYMBOL( nec7210_t1_delay );
+EXPORT_SYMBOL( nec7210_request_system_control );
+EXPORT_SYMBOL( nec7210_take_control );
+EXPORT_SYMBOL( nec7210_go_to_standby );
+EXPORT_SYMBOL( nec7210_interface_clear );
+EXPORT_SYMBOL( nec7210_remote_enable );
+EXPORT_SYMBOL( nec7210_release_rfd_holdoff );
+EXPORT_SYMBOL( nec7210_return_to_local );
diff --git a/drivers/gpib/nec7210/read.c b/drivers/gpib/nec7210/read.c
new file mode 100644
index 0000000..1a39df3
--- /dev/null
+++ b/drivers/gpib/nec7210/read.c
@@ -0,0 +1,183 @@
+/***************************************************************************
+                              nec7210/read.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "board.h"
+#include <asm/dma.h>
+#include <linux/spinlock.h>
+
+static int pio_read( gpib_board_t *board, nec7210_private_t *priv, uint8_t *buffer,
+	size_t length, int *end, size_t *bytes_read)
+{
+	ssize_t retval = 0;
+
+	*bytes_read = 0;	
+	*end = 0;
+
+	while( *bytes_read < length )
+	{
+		if(wait_event_interruptible(board->wait,
+			test_bit(READ_READY_BN, &priv->state) ||
+			test_bit(DEV_CLEAR_BN, &priv->state) ||
+			test_bit(TIMO_NUM, &board->status)))
+		{
+			GPIB_DPRINTK("nec7210: pio read wait interrupted\n");
+			retval = -ERESTARTSYS;
+			break;
+		}
+		if( test_bit(READ_READY_BN, &priv->state) )
+		{
+			if(*bytes_read == 0)
+			{
+				/* We set the handshake mode here because we know
+				* no new bytes will arrive (it has already arrived
+				* and is awaiting being read out of the chip) while we are changing
+				* modes.  This ensures we can reliably keep track
+				* of the holdoff state. */
+				nec7210_set_handshake_mode( board, priv, HR_HLDA );
+			}
+			buffer[ (*bytes_read)++ ] = nec7210_read_data_in( board, priv, end );
+			if( *end )
+				break;
+		}
+		if( test_bit( TIMO_NUM, &board->status ) )
+		{
+			GPIB_DPRINTK("interrupted by timeout\n");
+			retval = -ETIMEDOUT;
+			break;
+		}
+		if( test_bit( DEV_CLEAR_BN, &priv->state) )
+		{
+			GPIB_DPRINTK("interrupted by device clear\n");
+			retval = -EINTR;
+			break;
+		}
+
+		if(*bytes_read < length)
+			nec7210_release_rfd_holdoff( board, priv );
+
+		if(need_resched())
+			schedule();
+	}
+	return retval;
+}
+#if 0
+static ssize_t __dma_read(gpib_board_t *board, nec7210_private_t *priv, size_t length)
+{
+	ssize_t retval = 0;
+	size_t count = 0;
+	unsigned long flags, dma_irq_flags;
+
+	if(length == 0)
+		return 0;
+
+	spin_lock_irqsave(&board->spinlock, flags);
+
+	dma_irq_flags = claim_dma_lock();
+	disable_dma(priv->dma_channel);
+	/* program dma controller */
+	clear_dma_ff(priv->dma_channel);
+	set_dma_count(priv->dma_channel, length);
+	set_dma_addr (priv->dma_channel, priv->dma_buffer_addr);
+	set_dma_mode(priv->dma_channel, DMA_MODE_READ);
+	release_dma_lock(dma_irq_flags);
+
+	enable_dma(priv->dma_channel);
+
+	set_bit(DMA_READ_IN_PROGRESS_BN, &priv->state);
+	clear_bit(READ_READY_BN, &priv->state);
+
+	// enable nec7210 dma
+	nec7210_set_reg_bits( priv, IMR2, HR_DMAI, HR_DMAI );
+
+	spin_unlock_irqrestore(&board->spinlock, flags);
+
+	// wait for data to transfer
+	if(wait_event_interruptible(board->wait,
+		test_bit( DMA_READ_IN_PROGRESS_BN, &priv->state ) == 0 ||
+		test_bit( DEV_CLEAR_BN, &priv->state ) ||
+		test_bit( TIMO_NUM, &board->status ) ) )
+	{
+		printk("nec7210: dma read wait interrupted\n");
+		retval = -ERESTARTSYS;
+	}
+	if( test_bit( TIMO_NUM, &board->status ) )
+		retval = -ETIMEDOUT;
+	if( test_bit( DEV_CLEAR_BN, &priv->state ) )
+		retval = -EINTR;
+
+	// disable nec7210 dma
+	nec7210_set_reg_bits( priv, IMR2, HR_DMAI, 0 );
+
+	// record how many bytes we transferred
+	flags = claim_dma_lock();
+	clear_dma_ff(priv->dma_channel);
+	disable_dma(priv->dma_channel);
+	count += length - get_dma_residue(priv->dma_channel);
+	release_dma_lock(flags);
+
+	return retval ? retval : count;
+}
+
+static ssize_t dma_read(gpib_board_t *board, nec7210_private_t *priv, uint8_t *buffer, size_t length)
+{
+	size_t remain = length;
+	size_t transfer_size;
+	ssize_t retval = 0;
+
+	while(remain > 0)
+	{
+		transfer_size = (priv->dma_buffer_length < remain) ? priv->dma_buffer_length : remain;
+		retval = __dma_read(board, priv, transfer_size);
+		if(retval < 0) break;
+		memcpy(buffer, priv->dma_buffer, transfer_size);
+		remain -= retval;
+		buffer += retval;
+		if(test_bit(RECEIVED_END_BN, &priv->state)) break;
+	}
+
+	if(retval < 0) return retval;
+
+	return length - remain;
+}
+#endif
+int nec7210_read(gpib_board_t *board, nec7210_private_t *priv, uint8_t *buffer,
+	size_t length, int *end, size_t *bytes_read)
+{
+	ssize_t retval = 0;
+	
+	*end = 0;
+	*bytes_read = 0;
+	
+	if( length == 0 ) return 0;
+
+	clear_bit( DEV_CLEAR_BN, &priv->state ); // XXX wrong
+
+	nec7210_release_rfd_holdoff( board, priv );
+
+	retval = pio_read(board, priv, buffer, length, end, bytes_read);
+	
+	return retval;
+}
+
+EXPORT_SYMBOL(nec7210_read);
+
+
+
+
+
+
diff --git a/drivers/gpib/nec7210/util.c b/drivers/gpib/nec7210/util.c
new file mode 100644
index 0000000..de03a7d
--- /dev/null
+++ b/drivers/gpib/nec7210/util.c
@@ -0,0 +1,273 @@
+/***************************************************************************
+                              nec7210/util.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "board.h"
+#include <linux/delay.h>
+
+int nec7210_enable_eos(gpib_board_t *board, nec7210_private_t *priv, uint8_t eos_byte, int compare_8_bits)
+{
+	write_byte(priv, eos_byte, EOSR);
+	priv->auxa_bits |= HR_REOS;
+	if(compare_8_bits)
+		priv->auxa_bits |= HR_BIN;
+	else
+		priv->auxa_bits &= ~HR_BIN;
+	write_byte(priv, priv->auxa_bits, AUXMR);
+	return 0;
+}
+
+void nec7210_disable_eos(gpib_board_t *board, nec7210_private_t *priv)
+{
+	priv->auxa_bits &= ~HR_REOS;
+	write_byte(priv, priv->auxa_bits, AUXMR);
+}
+
+int nec7210_parallel_poll(gpib_board_t *board, nec7210_private_t *priv, uint8_t *result)
+{
+	int ret;
+
+	clear_bit(COMMAND_READY_BN, &priv->state);
+	// execute parallel poll
+	write_byte(priv, AUX_EPP, AUXMR);
+	// wait for result FIXME: support timeouts
+	ret = wait_event_interruptible(board->wait, test_bit(COMMAND_READY_BN, &priv->state));
+	if(ret)
+	{
+		printk("gpib: parallel poll interrupted\n");
+		return -ERESTARTSYS;
+	}
+	*result = read_byte(priv, CPTR);
+
+	return 0;
+}
+
+void nec7210_parallel_poll_configure( gpib_board_t *board,
+	nec7210_private_t *priv, unsigned int configuration )
+{
+	write_byte( priv, PPR | configuration , AUXMR );
+}
+
+void nec7210_parallel_poll_response( gpib_board_t *board, nec7210_private_t *priv, int ist )
+{
+	if( ist )
+		write_byte( priv, AUX_SPPF , AUXMR );
+	else
+		write_byte( priv, AUX_CPPF , AUXMR );
+}
+
+void nec7210_serial_poll_response(gpib_board_t *board, nec7210_private_t *priv, uint8_t status)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave( &board->spinlock, flags );
+	if(status & request_service_bit)
+		priv->srq_pending = 1;
+	else
+		priv->srq_pending = 0;
+	clear_bit(SPOLL_NUM, &board->status);
+	write_byte(priv, status, SPMR);
+	spin_unlock_irqrestore( &board->spinlock, flags );
+}
+
+uint8_t nec7210_serial_poll_status( gpib_board_t *board, nec7210_private_t *priv )
+{
+	return read_byte(priv, SPSR);
+}
+
+void nec7210_primary_address(const gpib_board_t *board, nec7210_private_t *priv, unsigned int address)
+{
+	// put primary address in address0
+	write_byte(priv, address & ADDRESS_MASK, ADR);
+}
+
+void nec7210_secondary_address(const gpib_board_t *board, nec7210_private_t *priv, unsigned int address, int enable)
+{
+	if(enable)
+	{
+		// put secondary address in address1
+		write_byte(priv, HR_ARS | (address & ADDRESS_MASK), ADR);
+		// go to address mode 2
+		priv->reg_bits[ ADMR ] &= ~HR_ADM0;
+		priv->reg_bits[ ADMR ] |= HR_ADM1;
+	}else
+	{
+		// disable address1 register
+		write_byte(priv, HR_ARS | HR_DT | HR_DL, ADR);
+		// go to address mode 1
+		priv->reg_bits[ ADMR ] |= HR_ADM0;
+		priv->reg_bits[ ADMR ] &= ~HR_ADM1;
+	}
+	write_byte( priv, priv->reg_bits[ ADMR ], ADMR );
+}
+
+static void update_talker_state(nec7210_private_t *priv, unsigned address_status_bits)
+{
+	if((address_status_bits & HR_TA))
+	{
+		if((address_status_bits & HR_NATN))
+		{
+			if(address_status_bits & HR_SPMS)
+			{
+				priv->talker_state = serial_poll_active;
+			}else
+			{
+				priv->talker_state = talker_active;
+			}
+		}else
+		{
+			priv->talker_state = talker_addressed;
+		}
+	}else
+	{
+		priv->talker_state = talker_idle;
+	}
+}
+
+static void update_listener_state(nec7210_private_t *priv, unsigned address_status_bits)
+{
+	if(address_status_bits & HR_LA)
+	{
+		if((address_status_bits & HR_NATN))
+		{
+			priv->listener_state = listener_active;
+		}else
+		{
+			priv->listener_state = listener_addressed;
+		}
+	}else
+	{
+		priv->listener_state = listener_idle;
+	}
+}
+
+unsigned int update_status_nolock( gpib_board_t *board, nec7210_private_t *priv )
+{
+	int address_status_bits;
+	uint8_t spoll_status;
+
+	if(priv == NULL) return 0;
+
+	address_status_bits = read_byte(priv, ADSR);
+	if(address_status_bits & HR_CIC)
+		set_bit(CIC_NUM, &board->status);
+	else
+		clear_bit(CIC_NUM, &board->status);
+	// check for talker/listener addressed
+	update_talker_state(priv, address_status_bits);
+	if(priv->talker_state == talker_active)
+	{
+		set_bit(TACS_NUM, &board->status);
+	}else
+		clear_bit(TACS_NUM, &board->status);
+	update_listener_state(priv, address_status_bits);
+	if(priv->listener_state == listener_active)
+	{
+		set_bit(LACS_NUM, &board->status);
+	}else
+		clear_bit(LACS_NUM, &board->status);
+	if(address_status_bits & HR_NATN)
+	{
+		clear_bit(ATN_NUM, &board->status);
+	}else
+	{
+		set_bit(ATN_NUM, &board->status);
+	}
+	spoll_status = nec7210_serial_poll_status(board, priv);
+	if(priv->srq_pending && (spoll_status & request_service_bit) == 0)
+	{
+		priv->srq_pending = 0;
+		set_bit(SPOLL_NUM, &board->status);
+	}
+//	GPIB_DPRINTK( "status 0x%x, state 0x%x\n", board->status, priv->state );
+
+	/* we rely on the interrupt handler to set the
+	 * rest of the status bits */
+
+	return board->status;
+}
+
+unsigned int nec7210_update_status(gpib_board_t *board, nec7210_private_t *priv,
+	unsigned int clear_mask )
+{
+	unsigned long flags;
+	unsigned int retval;
+
+	spin_lock_irqsave( &board->spinlock, flags );
+	board->status &= ~clear_mask;
+	retval = update_status_nolock( board, priv );
+	spin_unlock_irqrestore( &board->spinlock, flags );
+
+	return retval;
+}
+
+unsigned int nec7210_set_reg_bits( nec7210_private_t *priv, unsigned int reg,
+	unsigned int mask, unsigned int bits )
+{
+	priv->reg_bits[ reg ] &= ~mask;
+	priv->reg_bits[ reg ] |= mask & bits;
+	write_byte( priv, priv->reg_bits[ reg ], reg );
+	return priv->reg_bits[ reg ];
+}
+
+void nec7210_set_handshake_mode( gpib_board_t *board, nec7210_private_t *priv, int mode )
+{
+	unsigned long flags;
+
+	mode &= HR_HANDSHAKE_MASK;
+	
+	spin_lock_irqsave( &board->spinlock, flags );
+	if((priv->auxa_bits & HR_HANDSHAKE_MASK) != mode)
+	{
+		priv->auxa_bits &= ~HR_HANDSHAKE_MASK;
+		priv->auxa_bits |= mode;
+		write_byte( priv, priv->auxa_bits, AUXMR );
+	}
+	spin_unlock_irqrestore( &board->spinlock, flags );
+}
+
+uint8_t nec7210_read_data_in( gpib_board_t *board, nec7210_private_t *priv, int *end )
+{
+	unsigned long flags;
+	uint8_t data;
+
+	spin_lock_irqsave( &board->spinlock, flags );
+	data = read_byte( priv, DIR );
+	clear_bit( READ_READY_BN, &priv->state );
+	if( test_and_clear_bit( RECEIVED_END_BN, &priv->state ) )
+		*end = 1;
+	else
+		*end = 0;
+	spin_unlock_irqrestore( &board->spinlock, flags );
+
+	return data;
+}
+
+EXPORT_SYMBOL( nec7210_enable_eos );
+EXPORT_SYMBOL( nec7210_disable_eos );
+EXPORT_SYMBOL( nec7210_serial_poll_response );
+EXPORT_SYMBOL( nec7210_serial_poll_status );
+EXPORT_SYMBOL( nec7210_parallel_poll_configure );
+EXPORT_SYMBOL( nec7210_parallel_poll_response );
+EXPORT_SYMBOL( nec7210_parallel_poll );
+EXPORT_SYMBOL( nec7210_primary_address );
+EXPORT_SYMBOL( nec7210_secondary_address );
+EXPORT_SYMBOL( nec7210_update_status );
+EXPORT_SYMBOL( nec7210_set_reg_bits );
+EXPORT_SYMBOL( nec7210_set_handshake_mode );
+EXPORT_SYMBOL( nec7210_read_data_in );
+
diff --git a/drivers/gpib/nec7210/write.c b/drivers/gpib/nec7210/write.c
new file mode 100644
index 0000000..948665b
--- /dev/null
+++ b/drivers/gpib/nec7210/write.c
@@ -0,0 +1,236 @@
+/***************************************************************************
+                              nec7210/write.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "board.h"
+#include <linux/string.h>
+#include <asm/dma.h>
+
+static int pio_write_wait(gpib_board_t *board, nec7210_private_t *priv,
+	short wake_on_lacs, short wake_on_atn, short wake_on_bus_error)
+{
+	// wait until byte is ready to be sent
+	if(wait_event_interruptible(board->wait,
+		(test_bit(TACS_NUM, &board->status) && test_bit(WRITE_READY_BN, &priv->state)) ||
+		test_bit(DEV_CLEAR_BN, &priv->state) ||
+		(wake_on_bus_error && test_bit(BUS_ERROR_BN, &priv->state)) ||
+		(wake_on_lacs && test_bit(LACS_NUM, &board->status)) ||
+		(wake_on_atn && test_bit(ATN_NUM, &board->status)) ||
+		test_bit(TIMO_NUM, &board->status)))
+	{
+		GPIB_DPRINTK( "gpib write interrupted\n" );
+		return -ERESTARTSYS;
+	}
+	if(test_bit(TIMO_NUM, &board->status))
+	{
+		printk("nec7210: write timed out\n");
+		return -ETIMEDOUT;
+	}
+	if(test_bit(DEV_CLEAR_BN, &priv->state))
+	{
+		printk("nec7210: write interrupted by clear\n");
+		return -EINTR;
+	}
+	if(wake_on_bus_error && test_and_clear_bit(BUS_ERROR_BN, &priv->state))
+	{
+		GPIB_DPRINTK("nec7210: bus error on write\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int pio_write(gpib_board_t *board, nec7210_private_t *priv,
+	uint8_t *buffer, size_t length, size_t *bytes_written)
+{
+	size_t last_count = 0;
+	ssize_t retval = 0;
+	unsigned long flags;
+	const int max_bus_errors = (length > 1000) ? length : 1000;
+	int bus_error_count = 0;
+	*bytes_written = 0;
+	clear_bit(BUS_ERROR_BN, &priv->state);
+	while(*bytes_written < length)
+	{
+		if(need_resched())
+			schedule();
+
+		retval = pio_write_wait(board, priv, 0, 0, priv->type == NEC7210);
+		if(retval == -EIO)
+		{
+			/* resend last byte on bus error */
+			*bytes_written = last_count;
+			GPIB_DPRINTK("resending %c\n", buffer[*bytes_written]);
+			/* we can get unrecoverable bus errors,
+			* so give up after a while */
+			bus_error_count++;
+			if(bus_error_count > max_bus_errors) return retval;
+			else continue;
+		}else if( retval < 0 ) return retval;
+
+		spin_lock_irqsave(&board->spinlock, flags);
+		clear_bit(BUS_ERROR_BN, &priv->state);
+		clear_bit(WRITE_READY_BN, &priv->state);
+		last_count = *bytes_written;
+		write_byte(priv, buffer[(*bytes_written)++], CDOR);
+		spin_unlock_irqrestore(&board->spinlock, flags);
+	}
+	retval = pio_write_wait(board, priv, 1, 1, priv->type == NEC7210);
+	return retval;
+}
+#if 0
+static ssize_t __dma_write(gpib_board_t *board, nec7210_private_t *priv, dma_addr_t address, size_t length)
+{
+	unsigned long flags, dma_irq_flags;
+	int residue = 0;
+	int retval = 0;
+
+	spin_lock_irqsave(&board->spinlock, flags);
+
+	/* program dma controller */
+	dma_irq_flags = claim_dma_lock();
+	disable_dma(priv->dma_channel);
+	clear_dma_ff(priv->dma_channel);
+	set_dma_count(priv->dma_channel, length);
+	set_dma_addr(priv->dma_channel, address);
+	set_dma_mode(priv->dma_channel, DMA_MODE_WRITE );
+	enable_dma(priv->dma_channel);
+	release_dma_lock(dma_irq_flags);
+
+	// enable board's dma for output
+	nec7210_set_reg_bits( priv, IMR2, HR_DMAO, HR_DMAO );
+
+	clear_bit(WRITE_READY_BN, &priv->state);
+	set_bit(DMA_WRITE_IN_PROGRESS_BN, &priv->state);
+
+	spin_unlock_irqrestore(&board->spinlock, flags);
+
+	// suspend until message is sent
+	if(wait_event_interruptible(board->wait, test_bit(DMA_WRITE_IN_PROGRESS_BN, &priv->state) == 0 ||
+		test_bit( BUS_ERROR_BN, &priv->state ) || test_bit( DEV_CLEAR_BN, &priv->state ) ||
+		test_bit(TIMO_NUM, &board->status)))
+	{
+		GPIB_DPRINTK( "gpib write interrupted!\n" );
+		retval = -ERESTARTSYS;
+	}
+	if(test_bit(TIMO_NUM, &board->status))
+		retval = -ETIMEDOUT;
+	if( test_and_clear_bit( DEV_CLEAR_BN, &priv->state ) )
+		retval = -EINTR;
+	if( test_and_clear_bit( BUS_ERROR_BN, &priv->state ) )
+		retval = -EIO;
+
+	// disable board's dma
+	nec7210_set_reg_bits( priv, IMR2, HR_DMAO, 0 );
+
+	dma_irq_flags = claim_dma_lock();
+	clear_dma_ff(priv->dma_channel);
+	disable_dma(priv->dma_channel);
+	residue = get_dma_residue(priv->dma_channel);
+	release_dma_lock( dma_irq_flags );
+
+	if(residue)
+		retval = -EPIPE;
+
+	return retval ? retval : length;
+}
+
+static ssize_t dma_write(gpib_board_t *board, nec7210_private_t *priv, uint8_t *buffer, size_t length)
+{
+	size_t remain = length;
+	size_t transfer_size;
+	ssize_t retval = 0;
+
+	while(remain > 0)
+	{
+		transfer_size = (priv->dma_buffer_length < remain) ? priv->dma_buffer_length : remain;
+		memcpy(priv->dma_buffer, buffer, transfer_size);
+		retval = __dma_write(board, priv, priv->dma_buffer_addr, transfer_size);
+		if(retval < 0) break;
+		remain -= retval;
+		buffer += retval;
+	}
+
+	if(retval < 0) return retval;
+
+	return length - remain;
+}
+#endif
+int nec7210_write(gpib_board_t *board, nec7210_private_t *priv, uint8_t *buffer, size_t length,
+	int send_eoi, size_t *bytes_written)
+{
+	int retval = 0;
+
+	*bytes_written = 0;
+	clear_bit( DEV_CLEAR_BN, &priv->state ); //XXX
+
+	if(send_eoi)
+	{
+		length-- ; /* save the last byte for sending EOI */
+	}
+
+	if(length > 0)
+	{
+		if(0 /*priv->dma_channel*/)
+		{	// isa dma transfer
+/* dma writes are unreliable since they can't recover from bus errors
+ * (which happen when ATN is asserted in the middle of a write) */
+#if 0
+			retval = dma_write(board, priv, buffer, length);
+			if(retval < 0)
+				return retval;
+			else count += retval;
+#endif
+		}else
+		{	// PIO transfer
+			size_t num_bytes;
+			retval = pio_write(board, priv, buffer, length, &num_bytes);
+			*bytes_written += num_bytes;
+			if(retval < 0)
+			{
+				return retval;
+			}
+		}
+	}
+	if(send_eoi)
+	{
+		size_t num_bytes;
+		/*send EOI */
+		write_byte(priv, AUX_SEOI, AUXMR);
+
+		retval = pio_write(board, priv, &buffer[*bytes_written], 1, &num_bytes);
+		*bytes_written += num_bytes;
+		if(retval < 0)
+		{
+			return retval;
+		}
+	}
+
+	return retval;
+}
+
+EXPORT_SYMBOL(nec7210_write);
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/gpib/sys/Makefile b/drivers/gpib/sys/Makefile
new file mode 100644
index 0000000..55f5f34
--- /dev/null
+++ b/drivers/gpib/sys/Makefile
@@ -0,0 +1,9 @@
+EXTRA_CFLAGS += -Idrivers/gpib/include
+
+obj-$(CONFIG_FLUKE_GPIB) += gpib_common.o
+
+gpib_common-objs := osfuncs.o  osinit.o  ostimer.o osutil.o autopoll.o ibcac.o ibcmd.o \
+	ibgts.o ibinit.o iblines.o ibread.o ibrpp.o ibrsv.o ibsic.o \
+	ibsre.o ibutil.o ibwait.o ibwrite.o device.o event.o
+
+
diff --git a/drivers/gpib/sys/autopoll.c b/drivers/gpib/sys/autopoll.c
new file mode 100644
index 0000000..55c3ff0
--- /dev/null
+++ b/drivers/gpib/sys/autopoll.c
@@ -0,0 +1,159 @@
+/***************************************************************************
+                               sys/autopoll.c
+                             -------------------
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ibsys.h"
+#include "autopoll.h"
+
+static const unsigned int serial_timeout = 1000000;
+
+unsigned int num_status_bytes( const gpib_status_queue_t *dev )
+{
+	return dev->num_status_bytes;
+}
+
+// push status byte onto back of status byte fifo
+int push_status_byte( gpib_status_queue_t *device, uint8_t poll_byte )
+{
+	struct list_head *head = &device->status_bytes;
+	status_byte_t *status;
+	static const unsigned int max_num_status_bytes = 1024;
+	int retval;
+
+	if( num_status_bytes( device ) >= max_num_status_bytes )
+	{
+		uint8_t lost_byte;
+
+		device->dropped_byte = 1;
+		retval = pop_status_byte( device, &lost_byte );
+		if( retval < 0 ) return retval;
+	}
+
+	status = kmalloc( sizeof( status_byte_t ), GFP_KERNEL );
+	if( status == NULL ) return -ENOMEM;
+
+	INIT_LIST_HEAD( &status->list );
+	status->poll_byte = poll_byte;
+
+	list_add_tail( &status->list, head );
+
+	device->num_status_bytes++;
+
+	GPIB_DPRINTK( "pushed status byte 0x%x, %i in queue\n",
+		(int) poll_byte, num_status_bytes( device ) );
+
+	return 0;
+}
+
+// pop status byte from front of status byte fifo
+int pop_status_byte( gpib_status_queue_t *device, uint8_t *poll_byte )
+{
+	struct list_head *head = &device->status_bytes;
+	struct list_head *front = head->next;
+	status_byte_t *status;
+
+	if( num_status_bytes( device ) == 0 ) return -EIO;
+
+	if( front == head ) return -EIO;
+
+	if( device->dropped_byte )
+	{
+		device->dropped_byte = 0;
+		return -EPIPE;
+	}
+
+	status = list_entry( front, status_byte_t, list );
+	*poll_byte = status->poll_byte;
+
+	list_del( front );
+	kfree( status );
+
+	device->num_status_bytes--;
+
+	GPIB_DPRINTK( "popped status byte 0x%x, %i in queue\n",
+		(int) *poll_byte, num_status_bytes( device ) );
+
+	return 0;
+}
+
+gpib_status_queue_t * get_gpib_status_queue( gpib_board_t *board, unsigned int pad, int sad )
+{
+	gpib_status_queue_t *device;
+	struct list_head *list_ptr;
+	const struct list_head *head = &board->device_list;
+
+	for( list_ptr = head->next; list_ptr != head; list_ptr = list_ptr->next )
+	{
+		device = list_entry( list_ptr, gpib_status_queue_t, list );
+		if( gpib_address_equal( device->pad, device->sad, pad, sad ) )
+			return device;
+	}
+
+	return NULL;
+}
+
+int get_serial_poll_byte( gpib_board_t *board, unsigned int pad, int sad, unsigned int usec_timeout,
+		uint8_t *poll_byte )
+{
+	gpib_status_queue_t *device;
+
+	device = get_gpib_status_queue( board, pad, sad );
+	if( device == NULL ) return -EINVAL;
+
+	if( num_status_bytes( device ) )
+	{
+		return pop_status_byte( device, poll_byte );
+	}else
+	{
+		return dvrsp( board, pad, sad, usec_timeout, poll_byte );
+	}
+}
+
+int autopoll_all_devices( gpib_board_t *board )
+{
+	int retval;
+
+	GPIB_DPRINTK( "entered autopoll_all_devices()\n" );
+	if( mutex_lock_interruptible( &board->user_mutex ) )
+	{
+		return -ERESTARTSYS;
+	}
+	if(mutex_lock_interruptible(&board->big_gpib_mutex))
+	{
+		mutex_unlock( &board->user_mutex );
+		return -ERESTARTSYS;
+	}
+
+
+	GPIB_DPRINTK( "autopoll has board lock\n" );
+
+	retval = serial_poll_all( board, serial_timeout );
+	if( retval < 0 )
+	{
+		mutex_unlock(&board->big_gpib_mutex);
+		mutex_unlock( &board->user_mutex );
+		return retval;
+	}
+
+	GPIB_DPRINTK( "autopoll_all_devices() complete\n" );
+	/* need to wake wait queue in case someone is
+	* waiting on RQS */
+	wake_up_interruptible( &board->wait );
+	mutex_unlock(&board->big_gpib_mutex);
+	mutex_unlock( &board->user_mutex );
+
+	return retval;
+}
diff --git a/drivers/gpib/sys/autopoll.h b/drivers/gpib/sys/autopoll.h
new file mode 100644
index 0000000..7b38db9
--- /dev/null
+++ b/drivers/gpib/sys/autopoll.h
@@ -0,0 +1,31 @@
+/***************************************************************************
+                               sys/autopoll.h
+                             -------------------
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef GPIB_AUTOPOLL_H
+#define GPIB_AUTOPOLL_H
+
+#include "gpib_types.h"
+
+unsigned int num_status_bytes( const gpib_status_queue_t *dev );
+int push_status_byte( gpib_status_queue_t *device, uint8_t poll_byte );
+int pop_status_byte( gpib_status_queue_t *device, uint8_t *poll_byte );
+gpib_status_queue_t * get_gpib_status_queue( gpib_board_t *board, unsigned int pad, int sad );
+int get_serial_poll_byte( gpib_board_t *board, unsigned int pad, int sad,
+	unsigned int usec_timeout, uint8_t *poll_byte );
+int autopoll_all_devices( gpib_board_t *board );
+
+#endif // GPIB_AUTOPOLL_H
diff --git a/drivers/gpib/sys/device.c b/drivers/gpib/sys/device.c
new file mode 100644
index 0000000..3ed0ca3
--- /dev/null
+++ b/drivers/gpib/sys/device.c
@@ -0,0 +1,202 @@
+/***************************************************************************
+                              sys/device.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+#include "autopoll.h"
+#include <linux/delay.h>
+
+static int setup_serial_poll( gpib_board_t *board, unsigned int usec_timeout )
+{
+	uint8_t cmd_string[8];
+	int i;
+
+	GPIB_DPRINTK( "entering setup_serial_poll()\n" );
+
+	ibcac( board, 0 );
+
+	i = 0;
+	cmd_string[ i++ ] = UNL;
+	cmd_string[ i++ ] = MLA( board->pad );	/* controller's listen address */
+	if( board->sad >= 0 )
+		cmd_string[ i++ ] = MSA( board->sad );
+	cmd_string[ i++ ] = SPE;	//serial poll enable
+
+	osStartTimer( board, usec_timeout );
+	if( board->interface->command( board, cmd_string, i ) < i )
+	{
+		printk("gpib: failed to setup serial poll\n");
+		osRemoveTimer( board );
+		return -EIO;
+	}
+	osRemoveTimer( board );
+
+	return 0;
+}
+
+static int read_serial_poll_byte( gpib_board_t *board, unsigned int pad,
+	int sad, unsigned int usec_timeout, uint8_t *result )
+{
+	uint8_t cmd_string[8];
+	int end_flag;
+	int ret;
+	int i;
+	size_t nbytes;
+
+	GPIB_DPRINTK( "entering read_serial_poll_byte(), pad=%i sad=%i\n", pad, sad );
+
+	ibcac( board, 0);
+
+	i = 0;
+	// send talk address
+	cmd_string[i++] = MTA( pad );
+	if( sad >= 0 )
+		cmd_string[i++] = MSA( sad );
+
+	osStartTimer( board, usec_timeout );
+	if( board->interface->command( board, cmd_string, i ) < i )
+	{
+		printk("gpib: failed to setup serial poll\n");
+		osRemoveTimer( board );
+		return -EIO;
+	}
+
+	ibgts( board );
+
+	// read poll result
+	ret = board->interface->read( board, result, 1, &end_flag ,&nbytes);
+	if( ret < 0 || nbytes < 1)
+	{
+		printk( "gpib: serial poll failed\n" );
+		osRemoveTimer( board );
+		return -EIO;
+	}
+	osRemoveTimer( board );
+
+	return 0;
+}
+
+static int cleanup_serial_poll( gpib_board_t *board, unsigned int usec_timeout )
+{
+	uint8_t cmd_string[8];
+
+	GPIB_DPRINTK( "entering cleanup_serial_poll()\n" );
+
+	ibcac( board, 0 );
+
+	cmd_string[ 0 ] = SPD;	/* disable serial poll bytes */
+	cmd_string[ 1 ] = UNT;
+	osStartTimer( board, usec_timeout );
+	if( board->interface->command( board, cmd_string, 2 ) < 2 )
+	{
+		printk( "gpib: failed to disable serial poll\n" );
+		osRemoveTimer( board );
+		return -EIO;
+	}
+	osRemoveTimer( board );
+
+	return 0;
+}
+
+static int serial_poll_single( gpib_board_t *board, unsigned int pad, int sad,
+	unsigned int usec_timeout, uint8_t *result )
+{
+	int retval, cleanup_retval;
+
+	retval = setup_serial_poll( board, usec_timeout );
+	if( retval < 0 ) return retval;
+	retval = read_serial_poll_byte( board, pad, sad, usec_timeout, result );
+	cleanup_retval = cleanup_serial_poll( board, usec_timeout );
+	if( retval < 0 ) return retval;
+	if( cleanup_retval < 0 ) return retval;
+
+	return 0;
+}
+
+int serial_poll_all( gpib_board_t *board, unsigned int usec_timeout )
+{
+	int retval = 0;
+	struct list_head *cur;
+	const struct list_head *head = NULL;
+	gpib_status_queue_t *device;
+	uint8_t result;
+	unsigned int num_bytes = 0;
+
+	GPIB_DPRINTK( "entering serial_poll_all()\n" );
+
+	head = &board->device_list;
+	if( head->next == head )
+	{
+		return 0;
+	}
+
+	retval = setup_serial_poll( board, usec_timeout );
+	if( retval < 0 ) return retval;
+
+	for( cur = head->next; cur != head; cur = cur->next )
+	{
+		device = list_entry( cur, gpib_status_queue_t, list );
+		retval = read_serial_poll_byte( board,
+			device->pad, device->sad, usec_timeout, &result );
+		if( retval < 0 ) continue;
+		if( result & request_service_bit )
+		{
+			retval = push_status_byte( device, result );
+			if( retval < 0 ) continue;
+			num_bytes++;
+		}
+	}
+
+	retval = cleanup_serial_poll( board, usec_timeout );
+	if( retval < 0 ) return retval;
+
+	return num_bytes;
+}
+
+/*
+ * DVRSP
+ * This function performs a serial poll of the device with primary
+ * address pad and secondary address sad. If the device has no
+ * secondary adddress, pass a zero in for this argument.  At the
+ * end of a successful serial poll the response is returned in result.
+ * SPD and UNT are sent at the completion of the poll.
+ */
+
+int dvrsp( gpib_board_t *board, unsigned int pad, int sad,
+	unsigned int usec_timeout, uint8_t *result )
+{
+	int status = ibstatus( board );
+	int retval;
+
+	if( ( status & CIC ) == 0 )
+	{
+		printk("gpib: not CIC during serial poll\n");
+		return -1;
+	}
+
+	if( pad > gpib_addr_max || sad > gpib_addr_max )
+	{
+		printk("gpib: bad address for serial poll");
+		return -1;
+	}
+
+	retval = serial_poll_single( board, pad, sad, usec_timeout, result );
+	if( io_timed_out( board ) ) retval = -ETIMEDOUT;
+
+	return retval;
+}
+
diff --git a/drivers/gpib/sys/event.c b/drivers/gpib/sys/event.c
new file mode 100644
index 0000000..9d06eb9
--- /dev/null
+++ b/drivers/gpib/sys/event.c
@@ -0,0 +1,131 @@
+/***************************************************************************
+                               sys/event.c
+                             -------------------
+
+    copyright            : (C) 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include "gpibP.h"
+
+static int push_gpib_event_nolock( gpib_board_t *board, short event_type );
+static int pop_gpib_event_nolock( gpib_event_queue_t *queue, short *event_type );
+
+unsigned int num_gpib_events( const gpib_event_queue_t *queue )
+{
+	return queue->num_events;
+}
+
+// push event onto back of event queue
+int push_gpib_event( gpib_board_t *board, short event_type )
+{
+	unsigned long flags;
+	int retval;
+
+	spin_lock_irqsave( &board->event_queue.lock, flags );
+	retval = push_gpib_event_nolock( board, event_type );
+	spin_unlock_irqrestore( &board->event_queue.lock, flags );
+
+	if( event_type == EventDevTrg ) board->status |= DTAS;
+	if( event_type == EventDevClr ) board->status |= DCAS;
+
+	return retval;
+}
+
+static int push_gpib_event_nolock( gpib_board_t *board, short event_type )
+{
+	gpib_event_queue_t *queue = &board->event_queue;
+	struct list_head *head = &queue->event_head;
+	gpib_event_t *event;
+	static const unsigned int max_num_events = 1024;
+	int retval;
+
+	if( num_gpib_events( queue ) >= max_num_events )
+	{
+		short lost_event;
+
+		queue->dropped_event = 1;
+		retval = pop_gpib_event_nolock( queue, &lost_event );
+		if( retval < 0 )
+			return retval;
+	}
+
+	event = kmalloc( sizeof( gpib_event_t ), GFP_ATOMIC );
+	if( event == NULL )
+	{
+		queue->dropped_event = 1;
+		printk( "gpib: failed to allocate memory for event\n");
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD( &event->list );
+	event->event_type = event_type;
+
+	list_add_tail( &event->list, head );
+
+	queue->num_events++;
+
+	GPIB_DPRINTK( "pushed event %i, %i in queue\n",
+		(int) event_type, num_gpib_events( queue ) );
+
+	return 0;
+}
+
+// pop event from front of event queue
+int pop_gpib_event( gpib_event_queue_t *queue, short *event_type )
+{
+	unsigned long flags;
+	int retval;
+
+	spin_lock_irqsave( &queue->lock, flags );
+	retval = pop_gpib_event_nolock( queue, event_type );
+	spin_unlock_irqrestore( &queue->lock, flags );
+	return retval;
+}
+
+static int pop_gpib_event_nolock( gpib_event_queue_t *queue, short *event_type )
+{
+	struct list_head *head = &queue->event_head;
+	struct list_head *front = head->next;
+	gpib_event_t *event;
+
+	if( num_gpib_events( queue ) == 0 )
+	{
+		*event_type = EventNone;
+		return 0;
+	}
+
+	if( front == head ) return -EIO;
+
+	if( queue->dropped_event )
+	{
+		queue->dropped_event = 0;
+		return -EPIPE;
+	}
+
+	event = list_entry( front, gpib_event_t, list );
+	*event_type = event->event_type;
+
+	list_del( front );
+	kfree( event );
+
+	queue->num_events--;
+
+	GPIB_DPRINTK( "popped event %i, %i in queue\n",
+		(int) *event_type, num_gpib_events( queue ) );
+
+	return 0;
+}
+
+EXPORT_SYMBOL( push_gpib_event );
diff --git a/drivers/gpib/sys/ibcac.c b/drivers/gpib/sys/ibcac.c
new file mode 100644
index 0000000..f91967e
--- /dev/null
+++ b/drivers/gpib/sys/ibcac.c
@@ -0,0 +1,50 @@
+/***************************************************************************
+                               sys/ibcac.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+/*
+ * IBCAC
+ * Return to the controller active state from the
+ * controller standby state, i.e., turn ATN on.  Note
+ * that in order to enter the controller active state
+ * from the controller idle state, ibsic must be called.
+ * If v is non-zero, take control synchronously, if
+ * possible.  Otherwise, take control asynchronously.
+ */
+int ibcac( gpib_board_t *board, int sync )
+{
+	int status = ibstatus( board );
+	int retval;
+
+	if( ( status & CIC ) == 0 )
+	{
+		printk("gpib: not CIC during ibcac()\n");
+		return -1;
+	}
+
+	retval = board->interface->take_control( board, sync );
+	if( retval < 0 )
+		printk("gpib: error while becoming active controller\n");
+
+	board->interface->update_status( board, 0 );
+
+	return retval;
+}
+
+
+
+
diff --git a/drivers/gpib/sys/ibcmd.c b/drivers/gpib/sys/ibcmd.c
new file mode 100644
index 0000000..51b63d6
--- /dev/null
+++ b/drivers/gpib/sys/ibcmd.c
@@ -0,0 +1,70 @@
+/***************************************************************************
+                              sys/ibcmd.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+
+/*
+ * IBCMD
+ * Write cnt command bytes from buf to the GPIB.  The
+ * command operation terminates only on I/O complete.
+ *
+ * NOTE:
+ *      1.  Prior to beginning the command, the interface is
+ *          placed in the controller active state.
+ *      2.  Before calling ibcmd for the first time, ibsic
+ *          must be called to initialize the GPIB and enable
+ *          the interface to leave the controller idle state.
+ */
+ssize_t ibcmd( gpib_board_t *board, uint8_t *buf, size_t length )
+{
+	size_t	count = 0;
+	ssize_t ret = 0;
+	int status = ibstatus( board );
+
+	if(length == 0) return 0;
+
+	if((status & CIC) == 0)
+	{
+		printk("gpib: cannot send command when not controller-in-charge\n");
+		return -1;
+	}
+
+	osStartTimer( board, board->usec_timeout );
+
+	ret = ibcac( board, 0 );
+	if( ret == 0 )
+	{
+		ret = board->interface->command(board, buf, length - count);
+		if(ret < 0)
+		{
+			printk("gpib: error writing gpib command bytes\n");
+		}else
+		{
+			buf += ret;
+			count += ret;
+		}
+	}
+
+	osRemoveTimer(board);
+
+	if( io_timed_out( board ) )
+		ret = -ETIMEDOUT;
+
+	return ret ? ret : count;
+}
+
+
diff --git a/drivers/gpib/sys/ibgts.c b/drivers/gpib/sys/ibgts.c
new file mode 100644
index 0000000..b965676
--- /dev/null
+++ b/drivers/gpib/sys/ibgts.c
@@ -0,0 +1,45 @@
+/***************************************************************************
+                               sys/ibgts.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+
+/*
+ * IBGTS
+ * Go to the controller standby state from the controller
+ * active state, i.e., turn ATN off.
+ */
+
+int ibgts( gpib_board_t *board )
+{
+	int status = ibstatus( board );
+	int retval;
+
+	if( ( status & CIC ) == 0 )
+	{
+		printk( "gpib: not CIC during ibgts()\n" );
+		return -1;
+	}
+
+	retval = board->interface->go_to_standby( board );                    /* go to standby */
+	if( retval < 0 )
+		printk( "gpib: error while going to standby\n");
+
+	board->interface->update_status( board, 0 );
+
+	return retval;
+}
+
diff --git a/drivers/gpib/sys/ibinit.c b/drivers/gpib/sys/ibinit.c
new file mode 100644
index 0000000..c70c019
--- /dev/null
+++ b/drivers/gpib/sys/ibinit.c
@@ -0,0 +1,139 @@
+/***************************************************************************
+                               sys/ibinit.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ibsys.h"
+#include "autopoll.h"
+#include <linux/kthread.h>
+#include <linux/vmalloc.h>
+
+static int autospoll_wait_should_wake_up(gpib_board_t *board)
+{
+	int retval;
+
+	mutex_lock(&board->big_gpib_mutex);
+
+	retval = board->master && board->autospollers > 0 &&
+		atomic_read(&board->stuck_srq) &&
+		test_and_clear_bit(SRQI_NUM, &board->status);
+
+	mutex_unlock(&board->big_gpib_mutex);
+	return retval;
+}
+
+static int autospoll_thread(void *board_void)
+{
+	gpib_board_t *board = board_void;
+	int retval = 0;
+
+	GPIB_DPRINTK("entering autospoll thread\n" );
+
+	while(1)
+	{
+		wait_event_interruptible(board->wait,
+			kthread_should_stop() ||
+			autospoll_wait_should_wake_up(board));
+		GPIB_DPRINTK("autospoll wait satisfied\n" );
+		if(kthread_should_stop()) break;
+
+		mutex_lock(&board->big_gpib_mutex);
+		/* make sure we are still good after we have
+		 * lock */
+		if(board->autospollers <= 0 || board->master == 0)
+		{
+			mutex_unlock(&board->big_gpib_mutex);
+			continue;
+		}
+		mutex_unlock(&board->big_gpib_mutex);
+
+		if(try_module_get(board->provider_module))
+		{
+			retval = autopoll_all_devices(board);
+			module_put(board->provider_module);
+		}else
+			printk("gpib%i: %s: try_module_get() failed!\n", board->minor, __FUNCTION__);
+		if(retval <= 0)
+		{
+			printk("gpib%i: %s: struck SRQ\n", board->minor, __FUNCTION__);
+			atomic_set(&board->stuck_srq, 1);	// XXX could be better
+			set_bit(SRQI_NUM, &board->status);
+		}
+	}
+	printk("gpib%i: exiting autospoll thread\n", board->minor);
+	return retval;
+}
+
+int ibonline(gpib_board_t *board, gpib_board_config_t config)
+{
+	int retval;
+
+	if( board->online ) return -EBUSY;
+	if(board->interface == NULL) return -ENODEV;
+	retval = gpib_allocate_board( board );
+	if( retval < 0 ) return retval;
+
+	retval = board->interface->attach(board, config);
+	if(retval < 0)
+	{
+		board->interface->detach(board);
+		printk("gpib: interface attach failed\n");
+		return retval;
+	}
+	/* nios2nommu on 2.6.11 uclinux kernel has weird problems
+	with autospoll thread causing huge slowdowns */
+#ifndef CONFIG_NIOS2
+	board->autospoll_task = kthread_run(&autospoll_thread, board, "gpib%d_autospoll_kthread", board->minor);
+	retval = IS_ERR(board->autospoll_task);
+	if(retval)
+	{
+		printk("gpib: failed to create autospoll thread\n");
+		board->interface->detach(board);
+		return retval;
+	}
+#endif
+	board->online = 1;
+	GPIB_DPRINTK( "gpib: board online\n" );
+
+	return 0;
+}
+
+/* XXX need to make sure board is generally not in use (grab board lock?) */
+int iboffline( gpib_board_t *board )
+{
+	int retval;
+
+	if( board->online == 0 )
+	{
+		return 0;
+	}
+	if(board->interface == NULL) return -ENODEV;
+
+	if(board->autospoll_task != NULL && !IS_ERR(board->autospoll_task))
+	{
+		retval = kthread_stop(board->autospoll_task);
+		if(retval)
+			printk("gpib: kthread_stop returned %i\n", retval);
+		board->autospoll_task = NULL;
+	}
+
+	board->interface->detach( board );
+	gpib_deallocate_board( board );
+	board->online = 0;
+	GPIB_DPRINTK( "gpib: board offline\n" );
+
+	return 0;
+}
+
diff --git a/drivers/gpib/sys/iblines.c b/drivers/gpib/sys/iblines.c
new file mode 100644
index 0000000..f862a9b
--- /dev/null
+++ b/drivers/gpib/sys/iblines.c
@@ -0,0 +1,25 @@
+
+#include "gpibP.h"
+
+/*
+ * IBLINES
+ * Poll the GPIB control lines and return their status in buf.
+ *
+ *      LSB (bits 0-7)  -  VALID lines mask (lines that can be monitored).
+ * Next LSB (bits 8-15) - STATUS lines mask (lines that are currently set).
+ *
+ */
+int iblines( const gpib_board_t *board, short *lines)
+{
+	int retval;
+	
+	*lines = 0;
+	if( board->interface->line_status == NULL )
+	{
+		return 0;
+	}
+	retval = board->interface->line_status( board );
+	if(retval < 0) return retval;
+	*lines = retval;
+	return 0;
+}
diff --git a/drivers/gpib/sys/ibread.c b/drivers/gpib/sys/ibread.c
new file mode 100644
index 0000000..02c972a
--- /dev/null
+++ b/drivers/gpib/sys/ibread.c
@@ -0,0 +1,78 @@
+/***************************************************************************
+                              ibread.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002, 2004 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "gpibP.h"
+
+/*
+ * IBRD
+ * Read up to 'length' bytes of data from the GPIB into buf.  End
+ * on detection of END (EOI and or EOS) and set 'end_flag'.
+ *
+ * NOTE:
+ *      1.  The interface is placed in the controller standby
+ *          state prior to beginning the read.
+ *      2.  Prior to calling ibrd, the intended devices as well
+ *          as the interface board itself must be addressed by
+ *          calling ibcmd.
+ */
+
+int ibrd(gpib_board_t *board, uint8_t *buf, size_t length, int *end_flag, size_t *nbytes)
+{
+	ssize_t ret = 0;
+	int retval;
+	size_t bytes_read;
+
+	*nbytes = 0;
+	*end_flag = 0;	
+	if( length == 0 )
+	{
+		printk( "gpib: ibrd() called with zero length?\n");
+		return 0;
+	}
+
+	if( board->master )
+	{
+		retval = ibgts( board );
+		if( retval < 0 ) return retval;
+	}
+	/* XXX reseting timer here could cause timeouts take longer than they should,
+	 * since read_ioctl calls this
+	 * function in a loop, there is probably a similar problem with writes/commands */
+	osStartTimer( board, board->usec_timeout );
+
+	do
+	{
+		ret = board->interface->read(board, buf, length - *nbytes, end_flag, &bytes_read);
+		if(ret < 0)
+		{
+/*			printk("gpib read error\n");*/
+		}
+		buf += bytes_read;
+		*nbytes += bytes_read;
+		if(need_resched())
+		{
+			schedule();
+		}
+	}while(ret == 0 && *nbytes > 0 && *nbytes < length && *end_flag == 0);
+
+	osRemoveTimer(board);
+
+	return ret;
+}
+
diff --git a/drivers/gpib/sys/ibrpp.c b/drivers/gpib/sys/ibrpp.c
new file mode 100644
index 0000000..ea99e09
--- /dev/null
+++ b/drivers/gpib/sys/ibrpp.c
@@ -0,0 +1,60 @@
+/***************************************************************************
+                              sys/ibrpp.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+
+/*
+ * IBRPP
+ * Conduct a parallel poll and return the byte in buf.
+ *
+ * NOTE:
+ *      1.  Prior to conducting the poll the interface is placed
+ *          in the controller active state.
+ */
+int ibrpp(gpib_board_t *board, uint8_t *result )
+{
+	int retval = 0;
+
+	osStartTimer( board, board->usec_timeout );
+	retval = ibcac( board, 0 );
+	if( retval ) return -1;
+
+	if(board->interface->parallel_poll( board, result ) )
+	{
+		printk("gpib: parallel poll failed\n");
+		retval = -1;
+	}
+	osRemoveTimer(board);
+	return retval;
+}
+
+int ibppc( gpib_board_t *board, uint8_t configuration )
+{
+
+	configuration &= 0x1f;
+	board->interface->parallel_poll_configure( board, configuration );
+	board->parallel_poll_configuration = configuration;
+	
+	return 0;
+}
+
+
+
+
+
+
+
diff --git a/drivers/gpib/sys/ibrsv.c b/drivers/gpib/sys/ibrsv.c
new file mode 100644
index 0000000..a0d7622
--- /dev/null
+++ b/drivers/gpib/sys/ibrsv.c
@@ -0,0 +1,23 @@
+
+#include "gpibP.h"
+
+
+/*
+ * IBRSV
+ * Request service from the CIC and/or set the serial poll
+ * status byte.
+ */
+int ibrsv( gpib_board_t *board, uint8_t poll_status )
+{
+	int status = ibstatus( board );
+
+	if( ( status & CIC ) )
+	{
+		printk("gpib: interface requested service while CIC\n");
+		return -EINVAL;
+	}
+
+	board->interface->serial_poll_response( board, poll_status );
+
+	return 0;
+}
diff --git a/drivers/gpib/sys/ibsic.c b/drivers/gpib/sys/ibsic.c
new file mode 100644
index 0000000..fccf603
--- /dev/null
+++ b/drivers/gpib/sys/ibsic.c
@@ -0,0 +1,63 @@
+/***************************************************************************
+                              ibsic.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+#include <linux/delay.h>
+
+/*
+ * IBSIC
+ * Send IFC for at least 100 microseconds.
+ *
+ * NOTE:
+ *      1.  Ibsic must be called prior to the first call to
+ *          ibcmd in order to initialize the bus and enable the
+ *          interface to leave the controller idle state.
+ */
+int ibsic( gpib_board_t *board, unsigned int usec_duration )
+{
+	if( board->master == 0 )
+	{
+		printk( "gpib: tried to assert IFC when not system controller\n" );
+		return -1;
+	}
+
+	if( usec_duration < 100 ) usec_duration = 100;
+	if( usec_duration > 1000 )
+	{
+		usec_duration = 1000;
+		printk( "gpib: warning, shortening long udelay\n");
+	}
+
+	GPIB_DPRINTK( "sending interface clear\n" );
+	board->interface->interface_clear(board, 1);
+	udelay( usec_duration );
+	board->interface->interface_clear(board, 0);
+
+	return 0;
+}
+
+void ibrsc( gpib_board_t *board, int request_control )
+{
+	board->master = request_control != 0;
+	if( board->interface->request_system_control == NULL )
+	{
+		printk( "gpib: bug! driver does not implement request_system_control()\n" );
+		return;
+	}
+	board->interface->request_system_control( board, request_control );
+}
+
diff --git a/drivers/gpib/sys/ibsre.c b/drivers/gpib/sys/ibsre.c
new file mode 100644
index 0000000..bd201d7
--- /dev/null
+++ b/drivers/gpib/sys/ibsre.c
@@ -0,0 +1,39 @@
+/***************************************************************************
+                              ibsre.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+#include <linux/delay.h>
+
+/*
+ * IBSRE
+ * Send REN true if v is non-zero or false if v is zero.
+ */
+int ibsre( gpib_board_t *board, int enable )
+{
+	if(	board->master == 0 )
+	{
+		printk( "gpib: tried to set REN when not system controller\n" );
+		return -1;
+	}
+	
+	board->interface->remote_enable( board, enable );	/* set or clear REN */
+	if( !enable )
+		udelay(100);
+
+	return 0;
+}
+
diff --git a/drivers/gpib/sys/ibsys.h b/drivers/gpib/sys/ibsys.h
new file mode 100644
index 0000000..bca0006
--- /dev/null
+++ b/drivers/gpib/sys/ibsys.h
@@ -0,0 +1,21 @@
+#include "gpibP.h"
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/timer.h>
+
+#include <asm/io.h>
+#include <asm/segment.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <asm/uaccess.h>
+
+extern int gpib_allocate_board( gpib_board_t *board );
+extern void gpib_deallocate_board( gpib_board_t *board );
diff --git a/drivers/gpib/sys/ibutil.c b/drivers/gpib/sys/ibutil.c
new file mode 100644
index 0000000..8e8efae
--- /dev/null
+++ b/drivers/gpib/sys/ibutil.c
@@ -0,0 +1,134 @@
+
+#include "gpibP.h"
+#include "autopoll.h"
+/*
+ * IBPAD
+ * change the GPIB address of the interface board.  The address
+ * must be 0 through 30.  ibonl resets the address to PAD.
+ */
+int ibpad( gpib_board_t *board, unsigned int addr )
+{
+	if ( addr > 30 )
+	{
+		printk("gpib: invalid primary address %u\n", addr );
+		return -1;
+	}else
+	{
+		board->pad = addr;
+		if( board->online )
+			board->interface->primary_address( board, board->pad );
+		GPIB_DPRINTK( "set primary addr to %i\n", board->pad );
+	}
+	return 0;
+}
+
+
+/*
+ * IBSAD
+ * change the secondary GPIB address of the interface board.
+ * The address must be 0 through 30, or negative disables.  ibonl resets the
+ * address to SAD.
+ */
+int ibsad( gpib_board_t *board, int addr )
+{
+	if( addr > 30 )
+	{
+		printk("gpib: invalid secondary address %i, must be 0-30\n", addr);
+		return -1;
+	}else
+	{
+		board->sad = addr;
+		if( board->online )
+		{
+			if( board->sad >= 0 )
+			{
+				board->interface->secondary_address( board, board->sad, 1 );
+			}else
+			{
+				board->interface->secondary_address( board, 0, 0 );
+			}
+		}
+		GPIB_DPRINTK( "set secondary addr to %i\n", board->sad );
+	}
+	return 0;
+}
+
+/*
+ * IBEOS
+ * Set the end-of-string modes for I/O operations to v.
+ *
+ */
+int ibeos( gpib_board_t *board, int eos, int eosflags )
+{
+	int retval;
+	if( eosflags & ~EOS_MASK )
+	{
+		printk( "bad EOS modes\n" );
+		return -EINVAL;
+	}else
+	{
+		if( eosflags & REOS )
+		{
+			retval = board->interface->enable_eos( board, eos, eosflags & BIN );
+		}else
+		{
+			board->interface->disable_eos( board );
+			retval = 0;
+		}
+	}
+	return retval;
+}
+
+int ibstatus( gpib_board_t *board )
+{
+	return general_ibstatus( board, NULL, 0, 0, NULL);
+}
+
+int general_ibstatus( gpib_board_t *board, const gpib_status_queue_t *device,
+	int clear_mask, int set_mask, gpib_descriptor_t *desc )
+{
+	int status = 0;
+	short line_status;
+
+	if( board->private_data )
+	{
+		status = board->interface->update_status( board, clear_mask );
+		/* XXX should probably stop having drivers use TIMO bit in
+		 * board->status to avoid confusion */
+		status &= ~TIMO;
+		/* get real SRQI status if we can */
+		if(iblines(board, &line_status) == 0)
+		{
+			if((line_status & ValidSRQ))
+			{
+				if((line_status & BusSRQ))
+				{
+					status |= SRQI;
+				}else
+				{
+					status &= ~SRQI;
+				}
+			}
+		}
+	}
+	if( device )
+		if( num_status_bytes( device ) ) status |= RQS;
+
+	if( desc )
+	{
+		if( atomic_read(&desc->io_in_progress) )
+			status &= ~CMPL;
+		else
+			status |= CMPL;
+		if( set_mask & CMPL )
+			atomic_set(&desc->io_in_progress, 1);
+		else if( clear_mask & CMPL )
+			atomic_set(&desc->io_in_progress, 0);
+	}
+	if( num_gpib_events( &board->event_queue ) )
+		status |= EVENT;
+	else
+		status &= ~EVENT;
+
+	return status;
+}
diff --git a/drivers/gpib/sys/ibwait.c b/drivers/gpib/sys/ibwait.c
new file mode 100644
index 0000000..0e13ace
--- /dev/null
+++ b/drivers/gpib/sys/ibwait.c
@@ -0,0 +1,146 @@
+/***************************************************************************
+                              ibwait.c
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+#include "autopoll.h"
+#include <linux/sched.h>
+
+struct wait_info
+{
+	gpib_board_t *board;
+	struct timer_list timer;
+	volatile int timed_out;
+	unsigned long usec_timeout;
+};
+
+static void init_wait_info( struct wait_info *winfo )
+{
+	winfo->board = NULL;
+	init_timer( &winfo->timer );
+	winfo->timed_out = 0;
+}
+
+static int wait_satisfied( struct wait_info *winfo, gpib_status_queue_t *status_queue,
+	int wait_mask, int *status, gpib_descriptor_t *desc )
+{
+	gpib_board_t *board = winfo->board;
+	int temp_status;
+
+	if(mutex_lock_interruptible( &board->big_gpib_mutex ))
+	{
+		return -ERESTARTSYS;
+	}
+
+	temp_status = general_ibstatus( board, status_queue, 0, 0, desc );
+
+	mutex_unlock(&board->big_gpib_mutex);
+
+	if( winfo->timed_out )
+		temp_status |= TIMO;
+	else
+		temp_status &= ~TIMO;
+	if( wait_mask & temp_status )
+	{
+		*status = temp_status;
+		return 1;
+	}
+//XXX does wait for END work?
+	return 0;
+}
+
+static void wait_timeout( unsigned long arg )
+/* Watchdog timeout routine */
+{
+	struct wait_info *winfo = ( struct wait_info * ) arg;
+
+	winfo->timed_out = 1;
+	wake_up_interruptible( &winfo->board->wait );
+}
+
+/* install timer interrupt handler */
+static void startWaitTimer( struct wait_info *winfo )
+/* Starts the timeout task  */
+{
+	winfo->timed_out = 0;
+
+	if( winfo->usec_timeout > 0 )
+	{
+		winfo->timer.expires = jiffies + usec_to_jiffies( winfo->usec_timeout );
+		winfo->timer.function = wait_timeout;
+		winfo->timer.data = (unsigned long) winfo;
+		add_timer( &winfo->timer );              /* add timer           */
+	}
+}
+
+static void removeWaitTimer( struct wait_info *winfo )
+{
+	if( timer_pending( &winfo->timer ) )
+		del_timer_sync( &winfo->timer );
+}
+
+/*
+ * IBWAIT
+ * Check or wait for a GPIB event to occur.  The mask argument
+ * is a bit vector corresponding to the status bit vector.  It
+ * has a bit set for each condition which can terminate the wait
+ * If the mask is 0 then
+ * no condition is waited for.
+ */
+int ibwait( gpib_board_t *board, int wait_mask, int clear_mask, int set_mask,
+	int *status, unsigned long usec_timeout, gpib_descriptor_t *desc )
+{
+	int retval = 0;
+	gpib_status_queue_t *status_queue;
+	struct wait_info winfo;
+
+	if( desc->is_board ) status_queue = NULL;
+	else status_queue = get_gpib_status_queue( board, desc->pad, desc->sad );
+
+	if( wait_mask == 0 )
+	{
+		*status = general_ibstatus( board, status_queue, clear_mask, set_mask, desc );
+		return 0;
+	}
+
+	mutex_unlock( &board->big_gpib_mutex );
+
+	init_wait_info( &winfo );
+	winfo.board = board;
+	winfo.usec_timeout = usec_timeout;
+	startWaitTimer( &winfo );
+
+	if( wait_event_interruptible( board->wait,
+		wait_satisfied( &winfo, status_queue, wait_mask, status, desc ) ) )
+	{
+		printk( "wait interrupted\n" );
+		retval = -ERESTARTSYS;
+	}
+	removeWaitTimer( &winfo );
+
+	if(retval) return retval;
+	if(mutex_lock_interruptible( &board->big_gpib_mutex ))
+	{
+		return -ERESTARTSYS;
+	}
+
+	/* make sure we only clear status bits that we are reporting */
+	if( *status & clear_mask || set_mask )
+		general_ibstatus( board, status_queue, *status & clear_mask, set_mask, 0 );
+
+	return 0;
+}
diff --git a/drivers/gpib/sys/ibwrite.c b/drivers/gpib/sys/ibwrite.c
new file mode 100644
index 0000000..789a309
--- /dev/null
+++ b/drivers/gpib/sys/ibwrite.c
@@ -0,0 +1,58 @@
+/***************************************************************************
+                              ibwrite.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "gpibP.h"
+
+/*
+ * IBWRT
+ * Write cnt bytes of data from buf to the GPIB.  The write
+ * operation terminates only on I/O complete.
+ *
+ * NOTE:
+ *      1.  Prior to beginning the write, the interface is
+ *          placed in the controller standby state.
+ *      2.  Prior to calling ibwrt, the intended devices as
+ *          well as the interface board itself must be
+ *          addressed by calling ibcmd.
+ */
+int ibwrt(gpib_board_t *board, uint8_t *buf, size_t cnt, int send_eoi, size_t *bytes_written)
+{
+	int ret = 0;
+	int retval;
+
+	if( cnt == 0 )
+	{
+		printk( "gpib: ibwrt() called with zero length?\n" );
+		return 0;
+	}
+
+	if( board->master )
+	{
+		retval = ibgts( board );
+		if( retval < 0 ) return retval;
+	}
+	osStartTimer( board, board->usec_timeout );
+	ret = board->interface->write(board, buf, cnt, send_eoi, bytes_written);
+
+	if( io_timed_out( board ) )
+		ret = -ETIMEDOUT;
+
+	osRemoveTimer(board);
+
+	return ret;
+}
+
diff --git a/drivers/gpib/sys/osfuncs.c b/drivers/gpib/sys/osfuncs.c
new file mode 100644
index 0000000..d08caa5
--- /dev/null
+++ b/drivers/gpib/sys/osfuncs.c
@@ -0,0 +1,1408 @@
+/***************************************************************************
+                               sys/osfuncs.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ibsys.h"
+#include "autopoll.h"
+
+#include <linux/fcntl.h>
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/version.h>
+
+static int board_type_ioctl(gpib_file_private_t *file_priv, gpib_board_t *board, unsigned long arg);
+static int read_ioctl( gpib_file_private_t *file_priv, gpib_board_t *board,
+	unsigned long arg);
+static int write_ioctl( gpib_file_private_t *file_priv, gpib_board_t *board,
+	unsigned long arg);
+static int command_ioctl( gpib_file_private_t *file_priv, gpib_board_t *board,
+	unsigned long arg);
+static int open_dev_ioctl( struct file *filep, gpib_board_t *board, unsigned long arg );
+static int close_dev_ioctl( struct file *filep, gpib_board_t *board, unsigned long arg );
+static int serial_poll_ioctl( gpib_board_t *board, unsigned long arg );
+static int wait_ioctl( gpib_file_private_t *file_priv, gpib_board_t *board, unsigned long arg );
+static int parallel_poll_ioctl( gpib_board_t *board, unsigned long arg );
+static int online_ioctl( gpib_board_t *board, unsigned long arg );
+static int remote_enable_ioctl( gpib_board_t *board, unsigned long arg );
+static int take_control_ioctl( gpib_board_t *board, unsigned long arg );
+static int line_status_ioctl( gpib_board_t *board, unsigned long arg );
+static int pad_ioctl( gpib_board_t *board, gpib_file_private_t *file_priv,
+	unsigned long arg );
+static int sad_ioctl( gpib_board_t *board, gpib_file_private_t *file_priv,
+	unsigned long arg );
+static int eos_ioctl( gpib_board_t *board, unsigned long arg );
+static int request_service_ioctl( gpib_board_t *board, unsigned long arg );
+static int iobase_ioctl( gpib_board_t *board, unsigned long arg );
+static int irq_ioctl( gpib_board_t *board, unsigned long arg );
+static int dma_ioctl( gpib_board_t *board, unsigned long arg );
+static int autospoll_ioctl(gpib_board_t *board, unsigned long arg);
+static int mutex_ioctl( gpib_board_t *board, gpib_file_private_t *file_priv,
+	unsigned long arg );
+static int timeout_ioctl( gpib_board_t *board, unsigned long arg );
+static int status_bytes_ioctl( gpib_board_t *board, unsigned long arg );
+static int board_info_ioctl( const gpib_board_t *board, unsigned long arg );
+static int ppc_ioctl( gpib_board_t *board, unsigned long arg );
+static int query_board_rsv_ioctl( gpib_board_t *board, unsigned long arg );
+static int interface_clear_ioctl( gpib_board_t *board, unsigned long arg );
+static int select_pci_ioctl( gpib_board_t *board, unsigned long arg );
+static int event_ioctl( gpib_board_t *board, unsigned long arg );
+static int request_system_control_ioctl( gpib_board_t *board, unsigned long arg );
+static int t1_delay_ioctl( gpib_board_t *board, unsigned long arg );
+
+static int cleanup_open_devices( gpib_file_private_t *file_priv, gpib_board_t *board );
+
+static gpib_descriptor_t* handle_to_descriptor( const gpib_file_private_t *file_priv,
+	int handle )
+{
+	if( handle < 0 || handle >= GPIB_MAX_NUM_DESCRIPTORS )
+	{
+		printk( "gpib: invalid handle %i\n", handle );
+		return NULL;
+	}
+
+	return file_priv->descriptors[ handle ];
+}
+
+static int init_gpib_file_private( gpib_file_private_t *priv )
+{
+	memset(priv, 0, sizeof(*priv));
+	priv->descriptors[ 0 ] = kmalloc( sizeof( gpib_descriptor_t ), GFP_KERNEL );
+	if( priv->descriptors[ 0 ] == NULL )
+	{
+		printk( "gpib: failed to allocate default board descriptor\n" );
+		return -ENOMEM;
+	}
+	init_gpib_descriptor( priv->descriptors[ 0 ] );
+	priv->descriptors[ 0 ]->is_board = 1;
+	mutex_init(&priv->descriptors_mutex);
+	return 0;
+}
+
+int ibopen(struct inode *inode, struct file *filep)
+{
+	unsigned int minor = iminor(inode);
+	gpib_board_t *board;
+	gpib_file_private_t *priv;
+
+	if(minor >= GPIB_MAX_NUM_BOARDS)
+	{
+		printk("gpib: invalid minor number of device file\n");
+		return -ENXIO;
+	}
+
+	board = &board_array[minor];
+
+	filep->private_data = kmalloc( sizeof( gpib_file_private_t ), GFP_KERNEL );
+	if( filep->private_data == NULL )
+	{
+		return -ENOMEM;
+	}
+	priv = filep->private_data;
+	init_gpib_file_private( ( gpib_file_private_t * ) filep->private_data );
+
+	GPIB_DPRINTK( "gpib: opening minor %d\n", minor );
+
+	if(board->use_count == 0)
+	{
+		char module_string[ 32 ];
+		int retval;
+
+		snprintf(module_string, sizeof(module_string), "gpib%i", minor);
+		retval = request_module( module_string );
+		if( retval )
+		{
+			GPIB_DPRINTK( "gpib: request module returned %i\n", retval );
+		}
+	}
+	if(board->interface)
+	{
+		if(!try_module_get(board->provider_module))
+		{
+			printk("gpib: try_module_get() failed\n");
+			return -ENOSYS;
+		}
+		board->use_count++;
+		priv->got_module = 1;
+	}
+	return 0;
+}
+
+
+int ibclose(struct inode *inode, struct file *filep)
+{
+	unsigned int minor = iminor(inode);
+	gpib_board_t *board;
+	gpib_file_private_t *priv = filep->private_data;
+
+	if(minor >= GPIB_MAX_NUM_BOARDS)
+	{
+		printk("gpib: invalid minor number of device file\n");
+		return -ENODEV;
+	}
+
+	GPIB_DPRINTK( "gpib: closing minor %d\n", minor );
+
+	board = &board_array[ minor ];
+
+	if( priv )
+	{
+		cleanup_open_devices( priv, board );
+		if( atomic_read(&priv->holding_mutex) )
+			mutex_unlock( &board->user_mutex );
+
+		if(priv->got_module && board->use_count)
+		{
+			module_put(board->provider_module);
+			--board->use_count;
+		}
+		kfree( filep->private_data );
+		filep->private_data = NULL;
+	}
+
+	return 0;
+}
+
+
+
+long ibioctl(struct file *filep, unsigned int cmd, unsigned long arg)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+	unsigned int minor = iminor(filep->f_dentry->d_inode);
+#else
+	unsigned int minor = iminor(filep->f_path.dentry->d_inode);
+#endif
+	gpib_board_t *board;
+	gpib_file_private_t *file_priv = filep->private_data;
+	long retval = -ENOTTY;
+
+	if( minor >= GPIB_MAX_NUM_BOARDS )
+	{
+		printk("gpib: invalid minor number of device file\n");
+		return -ENODEV;
+	}
+	board = &board_array[ minor ];
+
+	if(mutex_lock_interruptible(&board->big_gpib_mutex))
+	{
+		return -ERESTARTSYS;
+	}
+
+	GPIB_DPRINTK( "pid %i, minor %i, ioctl %d, interface=%s, use=%d, onl=%d\n",
+		current->pid, minor, cmd & 0xff,
+		board->interface ? board->interface->name : "",
+		board->use_count,
+		board->online );
+
+	switch( cmd )
+	{
+		case CFCBOARDTYPE:
+			retval = board_type_ioctl(file_priv, board, arg);
+			goto done;
+			break;
+		case IBONL:
+			retval = online_ioctl( board, arg );
+			goto done;
+			break;
+		default:
+			break;
+	}
+	if( board->interface == NULL )
+	{
+		printk("gpib: no gpib board configured on /dev/gpib%i\n", minor);
+		retval = -ENODEV;
+		goto done;
+	}
+	if(file_priv->got_module == 0)
+	{
+		if(!try_module_get(board->provider_module))
+		{
+			printk("gpib: try_module_get() failed\n");
+			retval = -ENOSYS;
+			goto done;
+		}
+		file_priv->got_module = 1;
+		board->use_count++;
+	}
+	switch( cmd )
+	{
+		case CFCBASE:
+			retval = iobase_ioctl( board, arg );
+			goto done;
+			break;
+		case CFCIRQ:
+			retval = irq_ioctl( board, arg );
+			goto done;
+			break;
+		case CFCDMA:
+			retval = dma_ioctl( board, arg );
+			goto done;
+			break;
+		case IBAUTOSPOLL:
+			retval = autospoll_ioctl(board, arg);
+			goto done;
+			break;
+		case IBBOARD_INFO:
+			retval = board_info_ioctl( board, arg );
+			goto done;
+			break;
+		case IBMUTEX:
+			/* Need to unlock board->big_gpib_mutex before potentially locking board->user_mutex
+			   to maintain consistent locking order */
+			mutex_unlock(&board->big_gpib_mutex);
+			return mutex_ioctl( board, file_priv, arg );
+			break;
+		case IBPAD:
+			retval = pad_ioctl( board, file_priv, arg );
+			goto done;
+			break;
+		case IBSAD:
+			retval = sad_ioctl( board, file_priv, arg );
+			goto done;
+			break;
+		case IBSELECT_PCI:
+			retval = select_pci_ioctl( board, arg );
+			goto done;
+			break;
+		default:
+			break;
+	}
+
+	if( !board->online )
+	{
+		printk( "gpib: ioctl %i invalid for offline board\n",
+			cmd & 0xff );
+		retval = -EINVAL;
+		goto done;
+	}
+
+	switch( cmd )
+	{
+		case IBEVENT:
+			retval = event_ioctl( board, arg );
+			goto done;
+			break;
+		case IBCLOSEDEV:
+			retval = close_dev_ioctl( filep, board, arg );
+			goto done;
+			break;
+		case IBOPENDEV:
+			retval = open_dev_ioctl( filep, board, arg );
+			goto done;
+			break;
+		case IBSPOLL_BYTES:
+			retval = status_bytes_ioctl( board, arg );
+			goto done;
+			break;
+		case IBWAIT:
+			retval = wait_ioctl( file_priv, board, arg );
+			if(retval == -ERESTARTSYS) return retval;
+			goto done;
+			break;
+		case IBLINES:
+			retval = line_status_ioctl( board, arg );
+			goto done;
+			break;
+		case IBLOC:
+			board->interface->return_to_local( board );
+			retval = 0;
+			goto done;
+			break;
+		default:
+			break;
+	}
+
+	spin_lock(&board->locking_pid_spinlock);
+	if( current->pid != board->locking_pid )
+	{
+		spin_unlock(&board->locking_pid_spinlock);
+		printk( "gpib: need to hold board lock to perform ioctl %i\n",
+			cmd & 0xff );
+		retval = -EPERM;
+		goto done;
+	}
+	spin_unlock(&board->locking_pid_spinlock);
+
+	switch( cmd )
+	{
+		case IB_T1_DELAY:
+			retval = t1_delay_ioctl( board, arg );
+			goto done;
+			break;
+		case IBCAC:
+			retval = take_control_ioctl( board, arg );
+			goto done;
+			break;
+		case IBCMD:
+			/* IO ioctls can take a long time, we need to unlock board->big_gpib_mutex
+				before we call them. */
+			mutex_unlock(&board->big_gpib_mutex);
+			return command_ioctl( file_priv, board, arg );
+			break;
+		case IBEOS:
+			retval = eos_ioctl( board, arg );
+			goto done;
+			break;
+		case IBGTS:
+			retval = ibgts( board );
+			goto done;
+			break;
+		case IBPPC:
+			retval = ppc_ioctl( board, arg );
+			goto done;
+			break;
+		case IBQUERY_BOARD_RSV:
+			retval = query_board_rsv_ioctl( board, arg );
+			goto done;
+			break;
+		case IBRD:
+			/* IO ioctls can take a long time, we need to unlock board->big_gpib_mutex
+				before we call them. */
+			mutex_unlock(&board->big_gpib_mutex);
+			return read_ioctl( file_priv, board, arg );
+			break;
+		case IBRPP:
+			retval = parallel_poll_ioctl( board, arg );
+			goto done;
+			break;
+		case IBRSC:
+			retval = request_system_control_ioctl( board, arg );
+			goto done;
+			break;
+		case IBRSP:
+			retval = serial_poll_ioctl( board, arg );
+			goto done;
+			break;
+		case IBRSV:
+			retval = request_service_ioctl( board, arg );
+			goto done;
+			break;
+		case IBSIC:
+			retval = interface_clear_ioctl( board, arg );
+			goto done;
+			break;
+		case IBSRE:
+			retval = remote_enable_ioctl( board, arg );
+			goto done;
+			break;
+		case IBTMO:
+			retval = timeout_ioctl( board, arg );
+			goto done;
+			break;
+		case IBWRT:
+			/* IO ioctls can take a long time, we need to unlock board->big_gpib_mutex
+				before we call them. */
+			mutex_unlock(&board->big_gpib_mutex);
+			return write_ioctl( file_priv, board, arg );
+			break;
+		default:
+			retval = -ENOTTY;
+			goto done;
+			break;
+	}
+
+done:
+	mutex_unlock(&board->big_gpib_mutex);
+	return retval;
+}
+
+static int board_type_ioctl(gpib_file_private_t *file_priv, gpib_board_t *board, unsigned long arg)
+{
+	struct list_head *list_ptr;
+	board_type_ioctl_t cmd;
+	int retval;
+
+	if(!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	if(board->online)
+	{
+		printk("gpib: can't change board type while board is online.\n");
+		return -EBUSY;
+	}
+
+	retval = copy_from_user(&cmd, (void*)arg, sizeof(board_type_ioctl_t));
+	if(retval)
+	{
+		return retval;
+	}
+
+	for(list_ptr = registered_drivers.next; list_ptr != &registered_drivers; list_ptr = list_ptr->next)
+	{
+		gpib_interface_list_t *entry;
+
+		entry = list_entry(list_ptr, gpib_interface_list_t, list);
+		if(strcmp(entry->interface->name, cmd.name) == 0)
+		{
+			int i;
+			int had_module = file_priv->got_module;
+			if(board->use_count)
+			{
+				for(i = 0; i < board->use_count; ++i)
+				{
+					module_put(board->provider_module);
+				}
+				board->interface = NULL;
+				file_priv->got_module = 0;
+			}
+			board->interface = entry->interface;
+			board->provider_module = entry->module;
+			for(i = 0; i < board->use_count; ++i)
+			{
+				if(!try_module_get(entry->module))
+				{
+					board->use_count = i;
+					return -ENOSYS;
+				}
+			}
+			if(had_module == 0)
+			{
+				if(!try_module_get(entry->module))
+				{
+					return -ENOSYS;
+				}
+				++board->use_count;
+			}
+			file_priv->got_module = 1;
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int read_ioctl( gpib_file_private_t *file_priv, gpib_board_t *board,
+	unsigned long arg)
+{
+	read_write_ioctl_t read_cmd;
+	uint8_t *userbuf;
+	unsigned long remain;
+	int end_flag = 0;
+	int retval;
+	ssize_t read_ret = 0;
+	gpib_descriptor_t *desc;
+	size_t nbytes;
+
+	retval = copy_from_user(&read_cmd, (void*) arg, sizeof(read_cmd));
+	if (retval)
+		return -EFAULT;
+
+	if(read_cmd.completed_transfer_count > read_cmd.requested_transfer_count)
+		return -EINVAL;
+	
+	desc = handle_to_descriptor( file_priv, read_cmd.handle );
+	if( desc == NULL ) return -EINVAL;
+
+	BUG_ON(sizeof(userbuf) > sizeof(read_cmd.buffer_ptr));
+	userbuf = (uint8_t*)(unsigned long)read_cmd.buffer_ptr;
+	userbuf += read_cmd.completed_transfer_count;
+
+	remain = read_cmd.requested_transfer_count - read_cmd.completed_transfer_count;
+
+	/* Check write access to buffer */
+	if(!access_ok(VERIFY_WRITE, userbuf, remain))
+		return -EFAULT;
+
+	atomic_set(&desc->io_in_progress, 1);
+
+	/* Read buffer loads till we fill the user supplied buffer */
+	while(remain > 0 && end_flag == 0)
+	{
+		nbytes = 0;
+		read_ret = ibrd(board, board->buffer, (board->buffer_length < remain) ? board->buffer_length :
+			remain, &end_flag, &nbytes);
+		if(nbytes == 0) break;
+		retval = copy_to_user(userbuf, board->buffer, nbytes);
+		if(retval)
+		{
+			retval = -EFAULT;
+			break;
+		}
+		remain -= nbytes;
+		userbuf += nbytes;
+		if(read_ret < 0) break;
+	}
+	read_cmd.completed_transfer_count = read_cmd.requested_transfer_count - remain;
+	read_cmd.end = end_flag;
+	/* suppress errors (for example due to timeout or interruption by device clear)
+	if all bytes got sent.  This prevents races that can occur in the various drivers
+	if a device receives a device clear immediately after a transfer completes and
+	the driver code wasn't careful enough to handle that case.
+	*/
+	if(remain == 0 || end_flag)
+	{
+		read_ret = 0;
+	}
+	if(retval == 0)
+		retval = copy_to_user((void*) arg, &read_cmd, sizeof(read_cmd));
+	atomic_set(&desc->io_in_progress, 0);
+	wake_up_interruptible( &board->wait );
+	if(retval) return -EFAULT;
+
+	return read_ret;
+}
+
+static int command_ioctl( gpib_file_private_t *file_priv,
+	gpib_board_t *board, unsigned long arg)
+{
+	read_write_ioctl_t cmd;
+	uint8_t *userbuf;
+	unsigned long remain;
+	int retval;
+	int fault = 0;
+	gpib_descriptor_t *desc;
+
+	retval = copy_from_user(&cmd, (void*) arg, sizeof(cmd));
+	if( retval )
+		return -EFAULT;
+
+	if(cmd.completed_transfer_count > cmd.requested_transfer_count)
+		return -EINVAL;
+
+	desc = handle_to_descriptor( file_priv, cmd.handle );
+	if( desc == NULL ) return -EINVAL;
+
+	userbuf = (uint8_t*)(unsigned long)cmd.buffer_ptr;
+	userbuf += cmd.completed_transfer_count;
+
+	remain = cmd.requested_transfer_count - cmd.completed_transfer_count;
+
+	/* Check read access to buffer */
+	if(!access_ok(VERIFY_READ, userbuf, remain))
+		return -EFAULT;
+
+	/* Write buffer loads till we empty the user supplied buffer */
+	atomic_set(&desc->io_in_progress, 1);
+	while( remain > 0 )
+	{
+		fault = copy_from_user(board->buffer, userbuf, (board->buffer_length < remain) ?
+			board->buffer_length : remain );
+		if(retval) retval = -EFAULT;
+		else
+			retval = ibcmd(board, board->buffer, (board->buffer_length < remain) ?
+				board->buffer_length : remain );
+		if(retval < 0)
+		{
+			atomic_set(&desc->io_in_progress, 0);
+			wake_up_interruptible( &board->wait );
+			break;
+		}
+		if( retval == 0 ) break;
+		remain -= retval;
+		userbuf += retval;
+	}
+
+	cmd.completed_transfer_count = cmd.requested_transfer_count - remain;
+
+	if(fault == 0)
+		fault = copy_to_user((void*) arg, &cmd, sizeof(cmd));
+	atomic_set(&desc->io_in_progress, 0);
+	wake_up_interruptible( &board->wait );
+	if( fault ) return -EFAULT;
+
+	return retval;
+}
+
+static int write_ioctl(gpib_file_private_t *file_priv, gpib_board_t *board,
+	unsigned long arg)
+{
+	read_write_ioctl_t write_cmd;
+	uint8_t *userbuf;
+	unsigned long remain;
+	int retval = 0;
+	int fault;
+	gpib_descriptor_t *desc;
+
+	fault = copy_from_user(&write_cmd, (void*) arg, sizeof(write_cmd));
+	if(fault)
+		return -EFAULT;
+
+	if(write_cmd.completed_transfer_count > write_cmd.requested_transfer_count)
+		return -EINVAL;
+
+	desc = handle_to_descriptor( file_priv, write_cmd.handle );
+	if( desc == NULL ) return -EINVAL;
+
+	userbuf = (uint8_t*)(unsigned long)write_cmd.buffer_ptr;
+	userbuf += write_cmd.completed_transfer_count;
+	
+	remain = write_cmd.requested_transfer_count - write_cmd.completed_transfer_count;
+
+	/* Check read access to buffer */
+	if(!access_ok(VERIFY_READ, userbuf, remain))
+		return -EFAULT;
+
+	atomic_set(&desc->io_in_progress, 1);
+
+	/* Write buffer loads till we empty the user supplied buffer */
+	while(remain > 0)
+	{
+		int send_eoi;
+		size_t bytes_written = 0;
+
+		send_eoi = remain <= board->buffer_length && write_cmd.end;
+		fault = copy_from_user(board->buffer, userbuf, (board->buffer_length < remain) ?
+			board->buffer_length : remain );
+		if(fault)
+		{
+			retval = -EFAULT;
+			break;
+		}
+		retval = ibwrt(board, board->buffer, (board->buffer_length < remain) ?
+			board->buffer_length : remain, send_eoi, &bytes_written);
+		remain -= bytes_written;
+		userbuf += bytes_written;
+		if(retval < 0)
+		{
+			break;
+		}
+	}
+	write_cmd.completed_transfer_count = write_cmd.requested_transfer_count - remain;
+	/* suppress errors (for example due to timeout or interruption by device clear)
+	if all bytes got sent.  This prevents races that can occur in the various drivers
+	if a device receives a device clear immediately after a transfer completes and
+	the driver code wasn't careful enough to handle that case.
+	*/
+	if(remain == 0)
+	{
+		retval = 0;
+	}
+	if(fault == 0)
+		fault = copy_to_user((void*) arg, &write_cmd, sizeof(write_cmd));
+	atomic_set(&desc->io_in_progress, 0);
+	wake_up_interruptible( &board->wait );
+	if(fault) return -EFAULT;
+
+	return retval;
+}
+
+static int status_bytes_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	gpib_status_queue_t *device;
+	spoll_bytes_ioctl_t cmd;
+	int retval;
+
+	retval = copy_from_user( &cmd, (void *) arg, sizeof( cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	device = get_gpib_status_queue( board, cmd.pad, cmd.sad );
+	if( device == NULL )
+		cmd.num_bytes = 0;
+	else
+		cmd.num_bytes = num_status_bytes( device );
+
+	retval = copy_to_user( (void *) arg, &cmd, sizeof( cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	return 0;
+}
+
+static int increment_open_device_count( struct list_head *head, unsigned int pad, int sad )
+{
+	struct list_head *list_ptr;
+	gpib_status_queue_t *device;
+
+	/* first see if address has already been opened, then increment
+	 * open count */
+	for( list_ptr = head->next; list_ptr != head; list_ptr = list_ptr->next )
+	{
+		device = list_entry( list_ptr, gpib_status_queue_t, list );
+		if( gpib_address_equal( device->pad, device->sad, pad, sad ) )
+		{
+			GPIB_DPRINTK( "incrementing open count for pad %i, sad %i\n",
+				device->pad, device->sad );
+			device->reference_count++;
+			return 0;
+		}
+	}
+
+	/* otherwise we need to allocate a new gpib_status_queue_t */
+	device = kmalloc( sizeof( gpib_status_queue_t ), GFP_ATOMIC );
+	if( device == NULL )
+		return -ENOMEM;
+	init_gpib_status_queue( device );
+	device->pad = pad;
+	device->sad = sad;
+	device->reference_count = 1;
+
+	list_add( &device->list, head );
+
+	GPIB_DPRINTK( "opened pad %i, sad %i\n",
+		device->pad, device->sad );
+
+	return 0;
+}
+
+static int subtract_open_device_count( struct list_head *head, unsigned int pad, int sad, unsigned int count )
+{
+	gpib_status_queue_t *device;
+	struct list_head *list_ptr;
+
+	for( list_ptr = head->next; list_ptr != head; list_ptr = list_ptr->next )
+	{
+		device = list_entry( list_ptr, gpib_status_queue_t, list );
+		if( gpib_address_equal( device->pad, device->sad, pad, sad ) )
+		{
+			GPIB_DPRINTK( "decrementing open count for pad %i, sad %i\n",
+				device->pad, device->sad );
+			if( count > device->reference_count )
+			{
+				printk( "gpib: bug! in subtract_open_device_count()\n" );
+				return -EINVAL;
+			}
+			device->reference_count -= count;
+			if( device->reference_count == 0 )
+			{
+				GPIB_DPRINTK( "closing pad %i, sad %i\n",
+					device->pad, device->sad );
+				list_del( list_ptr );
+				kfree( device );
+			}
+			return 0;
+		}
+	}
+	printk( "gpib: bug! tried to close address that was never opened!\n" );
+	return -EINVAL;
+}
+
+static inline int decrement_open_device_count( struct list_head *head, unsigned int pad, int sad )
+{
+	return subtract_open_device_count( head, pad, sad, 1 );
+}
+
+static int cleanup_open_devices( gpib_file_private_t *file_priv, gpib_board_t *board )
+{
+	int retval = 0;
+	int i;
+
+	for( i = 0; i < GPIB_MAX_NUM_DESCRIPTORS; i++ )
+	{
+		gpib_descriptor_t *desc;
+
+		desc = file_priv->descriptors[ i ];
+		if( desc == NULL ) continue;
+
+		if( desc->is_board == 0 )
+		{
+			retval = decrement_open_device_count( &board->device_list, desc->pad,
+				desc->sad );
+			if( retval < 0 ) return retval;
+		}
+		kfree( desc );
+		file_priv->descriptors[ i ] = NULL;
+	}
+
+	return 0;
+}
+
+static int open_dev_ioctl( struct file *filep, gpib_board_t *board, unsigned long arg )
+{
+	open_dev_ioctl_t open_dev_cmd;
+	int retval;
+	gpib_file_private_t *file_priv = filep->private_data;
+	int i;
+
+	retval = copy_from_user( &open_dev_cmd, ( void* ) arg, sizeof( open_dev_cmd ) );
+	if (retval)
+		return -EFAULT;
+
+	if(mutex_lock_interruptible(&file_priv->descriptors_mutex))
+	{
+		return -ERESTARTSYS;
+	}
+	for( i = 0; i < GPIB_MAX_NUM_DESCRIPTORS; i++ )
+		if( file_priv->descriptors[ i ] == NULL ) break;
+	if( i == GPIB_MAX_NUM_DESCRIPTORS )
+		return -ERANGE;
+	file_priv->descriptors[ i ] = kmalloc( sizeof( gpib_descriptor_t ), GFP_KERNEL );
+	if( file_priv->descriptors[ i ] == NULL )
+	{
+		mutex_unlock(&file_priv->descriptors_mutex);
+		return -ENOMEM;
+	}
+	init_gpib_descriptor( file_priv->descriptors[ i ] );
+
+	file_priv->descriptors[ i ]->pad = open_dev_cmd.pad;
+	file_priv->descriptors[ i ]->sad = open_dev_cmd.sad;
+	file_priv->descriptors[ i ]->is_board = open_dev_cmd.is_board;
+	mutex_unlock(&file_priv->descriptors_mutex);
+
+	retval = increment_open_device_count( &board->device_list, open_dev_cmd.pad, open_dev_cmd.sad );
+	if( retval < 0 )
+		return retval;
+
+	/* clear stuck srq state, since we may be able to find service request on
+	 * the new device */
+	atomic_set(&board->stuck_srq, 0);
+
+	open_dev_cmd.handle = i;
+	retval = copy_to_user( ( void* ) arg, &open_dev_cmd, sizeof( open_dev_cmd ) );
+	if (retval)
+		return -EFAULT;
+
+	return 0;
+}
+
+static int close_dev_ioctl( struct file *filep, gpib_board_t *board, unsigned long arg )
+{
+	close_dev_ioctl_t cmd;
+	gpib_file_private_t *file_priv = filep->private_data;
+	int retval;
+
+	retval = copy_from_user( &cmd, ( void* ) arg, sizeof( cmd ) );
+	if (retval)
+		return -EFAULT;
+
+	if( cmd.handle >= GPIB_MAX_NUM_DESCRIPTORS ) return -EINVAL;
+	if( file_priv->descriptors[ cmd.handle ] == NULL ) return -EINVAL;
+
+	retval = decrement_open_device_count( &board->device_list, file_priv->descriptors[ cmd.handle ]->pad,
+		file_priv->descriptors[ cmd.handle ]->sad );
+	if( retval < 0 ) return retval;
+
+	kfree( file_priv->descriptors[ cmd.handle ] );
+	file_priv->descriptors[ cmd.handle ] = NULL;
+
+	return 0;
+}
+
+static int serial_poll_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	serial_poll_ioctl_t serial_cmd;
+	int retval;
+
+	retval = copy_from_user( &serial_cmd, ( void* ) arg, sizeof( serial_cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	retval = get_serial_poll_byte( board, serial_cmd.pad, serial_cmd.sad, board->usec_timeout,
+		&serial_cmd.status_byte );
+	if( retval < 0 )
+		return retval;
+
+	retval = copy_to_user( ( void * ) arg, &serial_cmd, sizeof( serial_cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	return 0;
+}
+
+static int wait_ioctl( gpib_file_private_t *file_priv, gpib_board_t *board,
+	unsigned long arg )
+{
+	wait_ioctl_t wait_cmd;
+	int retval;
+	gpib_descriptor_t *desc;
+
+	retval = copy_from_user( &wait_cmd, ( void * ) arg, sizeof( wait_cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	desc = handle_to_descriptor( file_priv, wait_cmd.handle );
+	if( desc == NULL ) return -EINVAL;
+
+	retval = ibwait( board, wait_cmd.wait_mask, wait_cmd.clear_mask,
+		wait_cmd.set_mask, &wait_cmd.ibsta, wait_cmd.usec_timeout, desc );
+	if( retval < 0 ) return retval;
+
+	retval = copy_to_user( ( void * ) arg, &wait_cmd, sizeof( wait_cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	return 0;
+}
+
+static int parallel_poll_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	uint8_t poll_byte;
+	int retval;
+
+	retval = ibrpp( board, &poll_byte );
+	if( retval < 0 )
+		return retval;
+
+	retval = copy_to_user( ( void * ) arg, &poll_byte, sizeof( poll_byte ) );
+	if( retval )
+		return -EFAULT;
+
+	return 0;
+}
+
+static int online_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	online_ioctl_t online_cmd;
+	gpib_board_config_t config;
+	int retval;
+	void *init_data = NULL;
+
+	config.init_data = NULL;
+
+	if(!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	retval = copy_from_user( &online_cmd, ( void * ) arg, sizeof( online_cmd ) );
+	if(retval)
+		return -EFAULT;
+	if(online_cmd.init_data_length > 0)
+	{
+		config.init_data = vmalloc(online_cmd.init_data_length);
+		if(config.init_data == NULL)
+			return -ENOMEM;
+		BUG_ON(sizeof(init_data) > sizeof(online_cmd.init_data_ptr));
+		init_data = (void*)(unsigned long)(online_cmd.init_data_ptr);
+		retval = copy_from_user(config.init_data, init_data, online_cmd.init_data_length);
+		if(retval)
+		{
+			vfree(config.init_data);
+			return -EFAULT;
+		}
+		config.init_data_length = online_cmd.init_data_length;
+	}else
+	{
+		config.init_data = NULL;
+		config.init_data_length = 0;
+	}
+	if(online_cmd.online)
+		retval = ibonline(board, config);
+	else
+		retval = iboffline(board);
+	if(config.init_data)
+		vfree(config.init_data);
+	return retval;
+}
+
+static int remote_enable_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	int enable;
+	int retval;
+
+	retval = copy_from_user( &enable, ( void * ) arg, sizeof( enable ) );
+	if( retval )
+		return -EFAULT;
+
+	return ibsre( board, enable );
+}
+
+static int take_control_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	int synchronous;
+	int retval;
+
+	retval = copy_from_user( &synchronous, ( void * ) arg, sizeof( synchronous ) );
+	if( retval )
+		return -EFAULT;
+
+	return ibcac( board, synchronous );
+}
+
+static int line_status_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	short lines;
+	int retval;
+
+	retval = iblines( board, &lines );
+	if( retval < 0 )
+		return retval;
+
+	retval = copy_to_user( ( void * ) arg, &lines, sizeof( lines ) );
+	if( retval )
+		return -EFAULT;
+
+	return 0;
+}
+
+static int pad_ioctl( gpib_board_t *board, gpib_file_private_t *file_priv,
+	unsigned long arg )
+{
+	pad_ioctl_t cmd;
+	int retval;
+	gpib_descriptor_t *desc;
+
+	retval = copy_from_user( &cmd, ( void * ) arg, sizeof( cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	desc = handle_to_descriptor( file_priv, cmd.handle );
+	if( desc == NULL )
+		return -EINVAL;
+
+	if( desc->is_board )
+	{
+		retval = ibpad( board, cmd.pad );
+		if( retval < 0 ) return retval;
+	}else
+	{
+		retval = decrement_open_device_count( &board->device_list, desc->pad, desc->sad );
+		if( retval < 0 )
+			return retval;
+
+		desc->pad = cmd.pad;
+
+		retval = increment_open_device_count( &board->device_list, desc->pad, desc->sad );
+		if( retval < 0 )
+			return retval;
+	}
+
+	return 0;
+}
+
+static int sad_ioctl( gpib_board_t *board, gpib_file_private_t *file_priv,
+	unsigned long arg )
+{
+	sad_ioctl_t cmd;
+	int retval;
+	gpib_descriptor_t *desc;
+
+	retval = copy_from_user( &cmd, ( void * ) arg, sizeof( cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	desc = handle_to_descriptor( file_priv, cmd.handle );
+	if( desc == NULL )
+		return -EINVAL;
+
+	if( desc->is_board )
+	{
+		retval = ibsad( board, cmd.sad );
+		if( retval < 0 ) return retval;
+	}else
+	{
+		retval = decrement_open_device_count( &board->device_list, desc->pad, desc->sad );
+		if( retval < 0 )
+			return retval;
+
+		desc->sad = cmd.sad;
+
+		retval = increment_open_device_count( &board->device_list, desc->pad, desc->sad );
+		if( retval < 0 )
+			return retval;
+	}
+	return 0;
+}
+
+static int eos_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	eos_ioctl_t eos_cmd;
+	int retval;
+
+	retval = copy_from_user( &eos_cmd, ( void * ) arg, sizeof( eos_cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	return ibeos( board, eos_cmd.eos, eos_cmd.eos_flags );
+}
+
+static int request_service_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	uint8_t status_byte;
+	int retval;
+
+	retval = copy_from_user( &status_byte, ( void * ) arg, sizeof( status_byte ) );
+	if( retval )
+		return -EFAULT;
+
+	return ibrsv( board, status_byte );
+}
+
+static int iobase_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	uint64_t base_addr;
+	int retval;
+
+	if(!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	retval = copy_from_user( &base_addr, ( void * ) arg, sizeof( base_addr ) );
+	if( retval )
+		return -EFAULT;
+
+	BUG_ON(sizeof(void*) > sizeof(base_addr));
+	board->ibbase = (void*)(unsigned long)(base_addr);
+
+	return 0;
+}
+
+static int irq_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	unsigned int irq;
+	int retval;
+
+	if(!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	retval = copy_from_user( &irq, ( void * ) arg, sizeof( irq ) );
+	if( retval )
+		return -EFAULT;
+
+	board->ibirq = irq;
+
+	return 0;
+}
+
+static int dma_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	unsigned int dma_channel;
+	int retval;
+
+	if(!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	retval = copy_from_user( &dma_channel, ( void * ) arg, sizeof( dma_channel ) );
+	if( retval )
+		return -EFAULT;
+
+	board->ibdma = dma_channel;
+
+	return 0;
+}
+
+static int autospoll_ioctl(gpib_board_t *board, unsigned long arg)
+{
+	autospoll_ioctl_t enable;
+	int retval;
+
+	retval = copy_from_user( &enable, ( void * ) arg, sizeof( enable ) );
+	if(retval)
+		return -EFAULT;
+
+/*FIXME: should keep track of whether autospolling is on or off
+ * by descriptor.  That would also allow automatic decrement
+ * of autospollers when descriptors are closed. */
+	if(enable)
+		board->autospollers++;
+	else
+	{
+		if(board->autospollers <= 0)
+		{
+			printk("gpib: tried to set number of autospollers negative\n");
+			retval = -EINVAL;
+		}else
+		{
+			board->autospollers--;
+			retval = 0;
+		}
+	}
+	return retval;
+}
+
+static int mutex_ioctl( gpib_board_t *board, gpib_file_private_t *file_priv,
+	unsigned long arg )
+{
+	int retval, lock_mutex;
+
+	retval = copy_from_user( &lock_mutex, ( void * ) arg, sizeof( lock_mutex ) );
+	if( retval )
+		return -EFAULT;
+
+	if( lock_mutex )
+	{
+		retval = mutex_lock_interruptible(&board->user_mutex);
+		if(retval)
+		{
+			printk("gpib: ioctl interrupted while waiting on lock\n");
+			return -ERESTARTSYS;
+		}
+
+		spin_lock(&board->locking_pid_spinlock);
+		board->locking_pid = current->pid;
+		spin_unlock(&board->locking_pid_spinlock);
+
+		atomic_set(&file_priv->holding_mutex, 1);
+		GPIB_DPRINTK("locked board %d mutex\n", board->minor);
+	}else
+	{
+		spin_lock(&board->locking_pid_spinlock);
+		if( current->pid != board->locking_pid )
+		{
+			printk( "gpib: bug! pid %i tried to release mutex held by pid %i\n",
+				current->pid, board->locking_pid );
+			spin_unlock(&board->locking_pid_spinlock);
+			return -EPERM;
+		}
+		board->locking_pid = 0;
+		spin_unlock(&board->locking_pid_spinlock);
+
+		atomic_set(&file_priv->holding_mutex, 0);
+
+		mutex_unlock( &board->user_mutex );
+		GPIB_DPRINTK("unlocked board %i mutex\n", board->minor);
+	}
+
+
+	return 0;
+}
+
+static int timeout_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	unsigned int timeout;
+	int retval;
+
+	retval = copy_from_user( &timeout, ( void * ) arg, sizeof( timeout ) );
+	if( retval )
+		return -EFAULT;
+
+	board->usec_timeout = timeout;
+	GPIB_DPRINTK( "timeout set to %i usec\n", timeout );
+
+	return 0;
+}
+
+static int ppc_ioctl( gpib_board_t *board, unsigned long arg)
+{
+	ppoll_config_ioctl_t cmd;
+	int retval;
+
+	retval = copy_from_user( &cmd, ( void * ) arg, sizeof( cmd ) );
+	if( retval )
+		return -EFAULT;
+
+	if( cmd.set_ist )
+	{
+		board->ist = 1;
+		board->interface->parallel_poll_response( board, board->ist );
+	}else if( cmd.clear_ist )
+	{
+		board->ist = 0;
+		board->interface->parallel_poll_response( board, board->ist );
+	}
+
+	if( cmd.config )
+	{
+		retval = ibppc( board, cmd.config );
+		if( retval < 0 ) return retval;
+	}
+
+	return 0;
+}
+
+static int query_board_rsv_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	int status;
+	int retval;
+
+	status = board->interface->serial_poll_status( board );
+
+	retval = copy_to_user( ( void * ) arg, &status, sizeof( status ) );
+	if( retval )
+		return -EFAULT;
+
+	return 0;
+}
+
+static int board_info_ioctl( const gpib_board_t *board, unsigned long arg)
+{
+	board_info_ioctl_t info;
+	int retval;
+
+	info.pad = board->pad;
+	info.sad = board->sad;
+	info.parallel_poll_configuration = board->parallel_poll_configuration;
+	info.is_system_controller = board->master;
+	if( board->autospollers )
+		info.autopolling = 1;
+	else
+		info.autopolling = 0;
+	info.t1_delay = board->t1_nano_sec;
+	info.ist = board->ist;
+	info.no_7_bit_eos = board->interface->no_7_bit_eos;
+	retval = copy_to_user( ( void * ) arg, &info, sizeof( info ) );
+	if( retval )
+		return -EFAULT;
+
+	return 0;
+}
+
+static int interface_clear_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	unsigned int usec_duration;
+	int retval;
+
+	retval = copy_from_user( &usec_duration, ( void * ) arg, sizeof( usec_duration ) );
+	if( retval )
+		return -EFAULT;
+
+	return ibsic( board, usec_duration );
+}
+
+static int select_pci_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	select_pci_ioctl_t selection;
+	int retval;
+
+	if(!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	retval = copy_from_user( &selection, ( void * ) arg, sizeof( selection ) );
+	if( retval ) return -EFAULT;
+
+	board->pci_bus = selection.pci_bus;
+	board->pci_slot = selection.pci_slot;
+
+	return 0;
+}
+
+static int event_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	event_ioctl_t user_event;
+	int retval;
+	short event;
+
+	retval = pop_gpib_event( &board->event_queue, &event );
+	if( retval < 0 ) return retval;
+
+	user_event = event;
+
+	retval = copy_to_user( (void*) arg, &user_event, sizeof( user_event ) );
+	if( retval ) return -EFAULT;
+
+	return 0;
+}
+
+static int request_system_control_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	rsc_ioctl_t request_control;
+	int retval;
+
+	retval = copy_from_user( &request_control, ( void * ) arg, sizeof( request_control ) );
+	if( retval ) return -EFAULT;
+
+	ibrsc( board, request_control );
+
+	return 0;
+}
+
+static int t1_delay_ioctl( gpib_board_t *board, unsigned long arg )
+{
+	t1_delay_ioctl_t cmd;
+	unsigned int delay;
+	int retval;
+
+	if( board->interface->t1_delay == NULL )
+	{
+		printk("gpib: t1 delay not implemented in driver!\n" );
+		return -EIO;
+	}
+
+	retval = copy_from_user( &cmd, ( void * ) arg, sizeof( cmd ) );
+	if( retval ) return -EFAULT;
+
+	delay = cmd;
+
+	board->t1_nano_sec = board->interface->t1_delay( board, delay );
+
+	return 0;
+}
+
diff --git a/drivers/gpib/sys/osinit.c b/drivers/gpib/sys/osinit.c
new file mode 100644
index 0000000..688dd47
--- /dev/null
+++ b/drivers/gpib/sys/osinit.c
@@ -0,0 +1,268 @@
+/***************************************************************************
+                          osinit.c  -  description
+                             -------------------
+
+    begin                : Dec 2001
+    copyright            : (C) 2001, 2004 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ibsys.h"
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(IBMAJOR);
+
+struct file_operations ib_fops =
+{
+	owner: THIS_MODULE,
+	llseek: NULL,
+	unlocked_ioctl: &ibioctl,
+	compat_ioctl: &ibioctl,
+	open: &ibopen,
+	release: &ibclose,
+};
+
+gpib_board_t board_array[GPIB_MAX_NUM_BOARDS];
+
+LIST_HEAD(registered_drivers);
+
+void init_gpib_descriptor( gpib_descriptor_t *desc )
+{
+	desc->pad = 0;
+	desc->sad = -1;
+	desc->is_board = 0;
+	atomic_set(&desc->io_in_progress, 0);
+}
+
+void gpib_register_driver(gpib_interface_t *interface, struct module *provider_module)
+{
+	struct gpib_interface_list_struct *entry;
+
+	entry = kmalloc(sizeof(struct gpib_interface_list_struct), GFP_KERNEL);
+	if(entry == NULL)
+	{
+		printk("gpib: failed register %s interface, out of memory\n", interface->name);
+		return;
+	}
+	entry->interface = interface;
+	entry->module = provider_module;
+	list_add(&entry->list, &registered_drivers);
+	printk("gpib: registered %s interface\n", interface->name);
+}
+
+void gpib_unregister_driver(gpib_interface_t *interface)
+{
+	int i;
+	struct list_head *list_ptr;
+
+	for(i = 0; i < GPIB_MAX_NUM_BOARDS; i++)
+	{
+		gpib_board_t *board = &board_array[i];
+		if (board->interface == interface)
+		{
+			if( board->use_count > 0 )
+				printk("gpib: Warning:"
+					" deregistered interface %s in use\n",
+					interface->name);
+			iboffline( board );
+			board->interface = NULL;
+		}
+	}
+	for(list_ptr = registered_drivers.next; list_ptr != &registered_drivers;)
+	{
+		gpib_interface_list_t *entry;
+
+		entry = list_entry(list_ptr, gpib_interface_list_t, list);
+		list_ptr = list_ptr->next;
+		if(entry->interface == interface)
+		{
+			list_del(&entry->list);
+			kfree(entry);
+		}
+	}
+	printk("gpib: unregistered %s interface\n", interface->name);
+}
+
+void init_gpib_board( gpib_board_t *board )
+{
+	board->interface = NULL;
+	board->provider_module = NULL;
+	board->buffer = NULL;
+	board->buffer_length = 0;
+	board->status = 0;
+	init_waitqueue_head(&board->wait);
+	mutex_init(&board->user_mutex);
+	mutex_init(&board->big_gpib_mutex);
+	board->locking_pid = 0;
+	spin_lock_init(&board->locking_pid_spinlock);
+	spin_lock_init(&board->spinlock);
+	init_timer(&board->timer);
+	board->ibbase = 0;
+	board->ibirq = 0;
+	board->ibdma = 0;
+	board->pci_bus = -1;
+	board->pci_slot = -1;
+	board->private_data = NULL;
+	board->use_count = 0;
+	INIT_LIST_HEAD( &board->device_list );
+	board->pad = 0;
+	board->sad = -1;
+	board->usec_timeout = 3000000;
+	board->parallel_poll_configuration = 0;
+	board->online = 0;
+	board->autospollers = 0;
+	board->autospoll_task = NULL;
+	init_event_queue(&board->event_queue);
+	board->minor = -1;
+	init_gpib_pseudo_irq(&board->pseudo_irq);
+	board->master = 1;
+	atomic_set(&board->stuck_srq, 0);
+}
+
+int gpib_allocate_board( gpib_board_t *board )
+{
+	if( board->buffer == NULL )
+	{
+		board->buffer_length = 0x4000;
+		board->buffer = vmalloc( board->buffer_length );
+		if(board->buffer == NULL)
+		{
+			board->buffer_length = 0;
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+void gpib_deallocate_board( gpib_board_t *board )
+{
+	short dummy;
+
+	if( board->buffer )
+	{
+		vfree( board->buffer );
+		board->buffer = NULL;
+		board->buffer_length = 0;
+	}
+
+	while( num_gpib_events( &board->event_queue ) )
+		pop_gpib_event( &board->event_queue, &dummy );
+
+}
+
+void init_board_array( gpib_board_t *board_array, unsigned int length )
+{
+	int i;
+	for( i = 0; i < length; i++)
+	{
+		init_gpib_board( &board_array[i] );
+		board_array[i].minor = i;
+	}
+}
+
+void init_gpib_status_queue( gpib_status_queue_t *device )
+{
+	INIT_LIST_HEAD( &device->list );
+	INIT_LIST_HEAD( &device->status_bytes );
+	device->num_status_bytes = 0;
+	device->reference_count = 0;
+	device->dropped_byte = 0;
+}
+
+static struct class *gpib_class;
+
+static int __init gpib_common_init_module( void )
+{
+	int i;
+	printk("Linux-GPIB %s Driver\n", VERSION);
+	init_board_array(board_array, GPIB_MAX_NUM_BOARDS);
+	if(register_chrdev(IBMAJOR, "gpib", &ib_fops))
+	{
+		printk( "gpib: can't get major %d\n", IBMAJOR );
+		return -EIO;
+	}
+	gpib_class = class_create(THIS_MODULE, "gpib_common");
+	if(IS_ERR(gpib_class))
+	{
+		printk("gpib: failed to create gpib class\n");
+		unregister_chrdev(IBMAJOR, "gpib");
+		return PTR_ERR(gpib_class);
+	}
+	for(i = 0; i < GPIB_MAX_NUM_BOARDS; ++i)
+	{
+		device_create(gpib_class, 0, MKDEV(IBMAJOR, i), NULL, "gpib%i", i);
+	}
+	return 0;
+}
+
+static void __exit gpib_common_exit_module( void )
+{
+	int i;
+	for(i = 0; i < GPIB_MAX_NUM_BOARDS; ++i)
+	{
+		device_destroy(gpib_class, MKDEV(IBMAJOR, i));
+	}
+	class_destroy(gpib_class);
+	unregister_chrdev(IBMAJOR, "gpib");
+}
+
+module_init( gpib_common_init_module );
+module_exit( gpib_common_exit_module );
+
+struct pci_dev* gpib_pci_get_device( const gpib_board_t *board, unsigned int vendor_id,
+	unsigned int device_id, struct pci_dev *from)
+{
+	struct pci_dev *pci_device = from;
+
+	while( ( pci_device = pci_get_device( vendor_id, device_id, pci_device ) ) )
+	{
+		if( board->pci_bus >=0 && board->pci_bus != pci_device->bus->number )
+			continue;
+		if( board->pci_slot >= 0 && board->pci_slot !=
+			PCI_SLOT( pci_device->devfn ) )
+			continue;
+		return pci_device;
+	}
+	return NULL;
+}
+
+struct pci_dev* gpib_pci_get_subsys( const gpib_board_t *board, unsigned int vendor_id,
+	unsigned int device_id, unsigned ss_vendor, unsigned ss_device,
+	struct pci_dev *from)
+{
+	struct pci_dev *pci_device = from;
+
+	while((pci_device = pci_get_subsys( vendor_id, device_id, ss_vendor, ss_device, pci_device)))
+	{
+		if(board->pci_bus >=0 && board->pci_bus != pci_device->bus->number)
+			continue;
+		if(board->pci_slot >= 0 && board->pci_slot !=
+			PCI_SLOT( pci_device->devfn))
+			continue;
+		return pci_device;
+	}
+	return NULL;
+}
+
+EXPORT_SYMBOL( gpib_register_driver );
+EXPORT_SYMBOL( gpib_unregister_driver );
+EXPORT_SYMBOL( gpib_pci_get_device );
+EXPORT_SYMBOL(gpib_pci_get_subsys);
diff --git a/drivers/gpib/sys/ostimer.c b/drivers/gpib/sys/ostimer.c
new file mode 100644
index 0000000..3099612
--- /dev/null
+++ b/drivers/gpib/sys/ostimer.c
@@ -0,0 +1,64 @@
+/***************************************************************************
+                              ostimer.c
+                             -------------------
+
+    copyright            : (C) 2001, 2002 by Frank Mori Hess
+    email                : fmhess@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ibsys.h"
+
+/*
+ * Timer functions
+ */
+void watchdog_timeout( unsigned long arg )
+/* Watchdog timeout routine */
+{
+	gpib_board_t *board = (gpib_board_t*) arg;
+
+	set_bit( TIMO_NUM, &board->status );
+	wake_up_interruptible( &board->wait );
+}
+
+/* install timer interrupt handler */
+void osStartTimer( gpib_board_t *board, unsigned int usec_timeout )
+/* Starts the timeout task  */
+{
+	if( timer_pending( &board->timer ) )
+	{
+		printk("gpib: bug! timer already running?\n");
+		return;
+	}
+	clear_bit( TIMO_NUM, &board->status );
+
+	if( usec_timeout > 0 )
+	{
+		board->timer.expires = jiffies + usec_to_jiffies( usec_timeout );   /* set number of ticks */
+		board->timer.function = watchdog_timeout;
+		board->timer.data = (unsigned long) board;
+		add_timer( &board->timer );              /* add timer           */
+	}
+}
+
+void osRemoveTimer( gpib_board_t *board )
+/* Removes the timeout task */
+{
+	if( timer_pending( &board->timer ) )
+		del_timer_sync( &board->timer );
+}
+
+int io_timed_out( gpib_board_t *board )
+{
+	if( test_bit( TIMO_NUM, &board->status ) ) return 1;
+	return 0;
+}
+
diff --git a/drivers/gpib/sys/osutil.c b/drivers/gpib/sys/osutil.c
new file mode 100644
index 0000000..980aeb3
--- /dev/null
+++ b/drivers/gpib/sys/osutil.c
@@ -0,0 +1,101 @@
+
+#include "ibsys.h"
+#include <asm/io.h>
+#include <linux/sched.h>
+
+void writeb_wrapper(unsigned int value, void *address)
+{
+	writeb(value, address);
+};
+
+void writew_wrapper(unsigned int value, void *address)
+{
+	writew(value, address);
+};
+
+unsigned int readb_wrapper(void *address)
+{
+	return readb(address);
+};
+
+unsigned int readw_wrapper(void *address)
+{
+	return readw(address);
+};
+
+void outb_wrapper(unsigned int value, void *address)
+{
+	outb(value, (unsigned long)(address));
+};
+
+void outw_wrapper(unsigned int value, void *address)
+{
+	outw(value, (unsigned long)(address));
+};
+
+unsigned int inb_wrapper(void *address)
+{
+	return inb((unsigned long)(address));
+};
+
+unsigned int inw_wrapper(void *address)
+{
+	return inw((unsigned long)(address));
+};
+/* this is a function instead of a constant because of Suse
+ * defining HZ to be a function call to get_hz() */
+static inline int pseudo_irq_period(void)
+{
+	return (HZ + 99) / 100;
+}
+
+void pseudo_irq_handler(unsigned long arg)
+{
+	gpib_board_t *board = (gpib_board_t*) arg;
+	if(board->pseudo_irq.handler)
+		board->pseudo_irq.handler(0, board
+#ifdef HAVE_PT_REGS
+		, NULL
+#endif
+		);
+	else
+		printk("gpib: bug! pseudo_irq.handler is NULL\n");
+	if(atomic_read(&board->pseudo_irq.active))
+		mod_timer(&board->pseudo_irq.timer, jiffies + pseudo_irq_period());
+}
+
+int gpib_request_pseudo_irq(gpib_board_t *board, irqreturn_t (*handler)(int, void * PT_REGS_ARG))
+{
+	if(timer_pending(&board->pseudo_irq.timer) || board->pseudo_irq.handler)
+	{
+		printk("gpib: only one psuedo interrupt per board allowed\n");
+		return -1;
+	}
+
+	board->pseudo_irq.handler = handler;
+	board->pseudo_irq.timer.expires = jiffies + pseudo_irq_period();
+	board->pseudo_irq.timer.function = pseudo_irq_handler;
+	board->pseudo_irq.timer.data = (unsigned long) board;
+	atomic_set(&board->pseudo_irq.active, 1);
+	add_timer(&board->pseudo_irq.timer);
+
+	return 0;
+}
+
+void gpib_free_pseudo_irq(gpib_board_t *board)
+{
+	atomic_set(&board->pseudo_irq.active, 0);
+	del_timer_sync(&board->pseudo_irq.timer);
+	board->pseudo_irq.handler = NULL;
+}
+
+EXPORT_SYMBOL( writeb_wrapper );
+EXPORT_SYMBOL( readb_wrapper );
+EXPORT_SYMBOL( outb_wrapper );
+EXPORT_SYMBOL( inb_wrapper );
+EXPORT_SYMBOL( writew_wrapper );
+EXPORT_SYMBOL( readw_wrapper );
+EXPORT_SYMBOL( outw_wrapper );
+EXPORT_SYMBOL( inw_wrapper );
+EXPORT_SYMBOL(gpib_request_pseudo_irq);
+EXPORT_SYMBOL(gpib_free_pseudo_irq);
-- 
1.8.4.5

